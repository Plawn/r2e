//! Compile-time type-level list for tracking provided bean types.
//!
//! Used by [`AppBuilder`](crate::AppBuilder) to verify at compile time that
//! all field types required by a [`BeanState`](crate::BeanState) struct have
//! been provided before calling `build_state()`.

use std::marker::PhantomData;

/// Empty type-level list.
pub struct TNil;

/// Cons cell: `H` is a provided type, `T` is the rest of the list.
///
/// Uses `PhantomData<fn() -> (H, T)>` to avoid imposing `Send`/`Sync`
/// constraints on phantom type parameters.
pub struct TCons<H, T>(PhantomData<fn() -> (H, T)>);

/// Index witness: the element was found at the head of the list.
pub struct Here;

/// Index witness: the element was found somewhere in the tail.
pub struct There<T>(PhantomData<fn() -> T>);

/// Compile-time witness that type `H` is present in the type-level list `Self`,
/// located at position `Idx`.
///
/// The `Idx` parameter is an index witness (`Here` or `There<...>`) that guides
/// the compiler's trait resolution and avoids overlapping impls. It is always
/// inferred automatically — users never need to specify it.
#[diagnostic::on_unimplemented(
    message = "type `{H}` was not provided to the AppBuilder",
    label = "missing `.provide::<{H}>()` or `.with_bean::<{H}>()`",
    note = "every field type in the BeanState struct must be provided or registered as a bean before calling `build_state()`"
)]
pub trait Contains<H, Idx> {}

// Base case: H is the head of the list.
impl<H, T> Contains<H, Here> for TCons<H, T> {}

// Recursive case: H is somewhere in the tail.
impl<H, X, T, I> Contains<H, There<I>> for TCons<X, T> where T: Contains<H, I> {}

/// Marker trait: all types required by the state struct are present in the
/// type-level provision list `P`.
///
/// Generated automatically by `#[derive(BeanState)]`. The `Indices` parameter
/// bundles one index witness per unique field type so the compiler can
/// independently resolve each [`Contains`] bound. Users never specify
/// `Indices` — it is always inferred by the compiler.
///
/// ```ignore
/// // Generated by #[derive(BeanState)] for:
/// // struct Services { user_service: UserService, pool: Pool }
/// impl<__P, __I0, __I1> BuildableFrom<__P, (__I0, __I1)> for Services
/// where
///     __P: Contains<UserService, __I0>,
///     __P: Contains<Pool, __I1>,
/// {}
/// ```
#[diagnostic::on_unimplemented(
    message = "cannot build state `{Self}` from the current provisions",
    note = "one or more field types are missing — add `.provide(value)` or `.with_bean::<Type>()` calls before `.build_state()`"
)]
pub trait BuildableFrom<P, Indices> {}
