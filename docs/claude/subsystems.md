# R2E Subsystems Reference

## Cache (r2e-cache)

`TtlCache<K, V>` — thread-safe TTL cache backed by `DashMap`. Supports get, insert, remove, clear, evict_expired.

`CacheStore` trait — pluggable async cache backend. Default: `InMemoryStore` (DashMap-backed). Supports get, set, remove, clear, remove_by_prefix. Global singleton via `set_cache_backend()` / `cache_backend()`.

The `Cache` interceptor (in `r2e-utils`) uses the global `CacheStore` backend. `#[intercept(Cache::ttl(30).group("users"))]` stores in a named group; `#[intercept(CacheInvalidate::group("users"))]` clears by prefix.

## Rate Limiting (r2e-rate-limit)

`RateLimiter<K>` — generic token-bucket rate limiter keyed by arbitrary type. `RateLimitBackend` trait for pluggable backends (default: `InMemoryRateLimiter`). `RateLimitRegistry` — clonable handle stored in app state, used by the generated `RateLimitGuard`.

Key kinds: `"global"` (shared bucket), `"user"` (per authenticated user sub), `"ip"` (per X-Forwarded-For).

## Security (r2e-security)

- `AuthenticatedUser` implements `FromRequestParts` and `Identity` — extracts Bearer token, validates via `JwtValidator`, returns user with sub/email/roles/claims.
- `JwtValidator` supports both static keys (testing) and JWKS endpoint (production) via `JwksCache`.
- `SecurityConfig` — configuration for JWT validation (issuer, audience, JWKS URL, static keys).
- `#[roles("admin")]` attribute generates a guard that checks identity roles via the `Identity` trait and returns 403 if missing.
- Role extraction is trait-based (`RoleExtractor`) to support multiple OIDC providers; default (`DefaultRoleExtractor`) checks top-level `roles` and Keycloak's `realm_access.roles`.

## Events (r2e-events)

`EventBus` — in-process typed pub/sub. Events are dispatched by `TypeId`. Subscribers receive `Arc<E>`.

- `bus.subscribe(|event: Arc<MyEvent>| async { ... })` — register a handler.
- `bus.emit(event)` — fire-and-forget (spawns handlers as concurrent tasks).
- `bus.emit_and_wait(event)` — waits for all handlers to complete.

**Declarative consumers** via `#[consumer(bus = "field_name")]` in a `#[routes]` impl block. The controller must not have `#[inject(identity)]` struct fields (requires `StatefulConstruct`). Consumers are registered automatically by `AppBuilder::register_controller`.

## Scheduling (r2e-scheduler)

Scheduled tasks are auto-discovered via `register_controller()`, following the same pattern as event consumers. The scheduler runtime (`r2e-scheduler`) provides the `Scheduler` plugin (unit struct) that installs `CancellationToken`-based lifecycle management.

**Schedule data types** (in `r2e-core::scheduling`, zero new deps):
- `ScheduleConfig::Interval(duration)` — fixed interval.
- `ScheduleConfig::IntervalWithDelay { interval, initial_delay }` — with initial delay.
- `ScheduleConfig::Cron(expr)` — cron expression (via `cron` crate in the runtime).
- `ScheduledTaskDef<T>` — a named task definition with schedule and closure.
- `ScheduledResult` — trait for handling `()` or `Result<(), E>` return values.

**Declarative scheduling** via `#[scheduled]` attribute:
```rust
#[scheduled(every = 30)]                    // every 30 seconds
#[scheduled(every = 60, delay = 10)]        // first run after 10s
#[scheduled(cron = "0 */5 * * * *")]        // cron expression
```

**Registration:** install the `Scheduler` plugin before `build_state()`, then register controllers:
```rust
AppBuilder::new()
    .plugin(Scheduler)                        // install scheduler runtime (provides CancellationToken)
    .build_state::<Services, _, _>()
    .await
    .register_controller::<ScheduledJobs>()   // auto-discovers #[scheduled] methods
    .serve("0.0.0.0:3000")
```

The `Controller` trait's `scheduled_tasks()` method (auto-generated by `#[routes]`) returns `Vec<ScheduledTaskDef<T>>`. `register_controller()` collects these. `serve()` passes them to the scheduler backend, which spawns Tokio tasks. On shutdown, the `CancellationToken` is cancelled.

Controllers with `#[inject(identity)]` struct fields cannot be used for scheduling (no `StatefulConstruct` impl). Controllers using param-level `#[inject(identity)]` only retain `StatefulConstruct` and can be used for scheduling.

## Data (r2e-data)

- `Entity` trait — maps a Rust struct to a SQL table (table name, column list).
- `QueryBuilder` — fluent SQL query builder (`where_eq`, `where_like`, `order_by`, `limit`, `offset`).
- `Repository` trait — async CRUD interface (`find_by_id`, `find_all`, `create`, `update`, `delete`).
- `SqlxRepository` — SQLx-backed implementation of `Repository`.
- `Pageable` — pagination parameters extracted from query string (page, size, sort).
- `Page<T>` — paginated response wrapper (content, total_elements, total_pages, page, size).
- `DataError` — data-layer error type.

## OpenAPI (r2e-openapi)

- `OpenApiConfig` — configuration for the generated spec (title, version, description). `with_docs_ui(true)` enables the interactive documentation page.
- `AppBuilderOpenApiExt::with_openapi(config)` — registers OpenAPI routes.
- `SchemaRegistry` / `SchemaProvider` — JSON Schema collection for request/response types.
- Route metadata is collected from `Controller::route_metadata()` during `register_controller`.
- Always serves the spec at `/openapi.json`. When `docs_ui` is enabled, also serves an interactive API documentation UI at `/docs`.

## StatefulConstruct (r2e-core)

`StatefulConstruct<S>` trait allows constructing a controller from state alone (no HTTP context). Auto-generated by `#[derive(Controller)]` when the struct has no `#[inject(identity)]` fields. Used by:
- Consumer methods (`#[consumer]`) — event handlers that run outside HTTP requests
- Scheduled methods (`#[scheduled]`) — background tasks

Controllers with `#[inject(identity)]` struct fields do NOT get this impl. Attempting to use them in consumer/scheduled context produces a compile error with a diagnostic message via `#[diagnostic::on_unimplemented]`. Controllers using param-level `#[inject(identity)]` only retain `StatefulConstruct` — this is the key advantage of the mixed controller pattern.

## AppBuilder (r2e-core)

Fluent API for assembling a R2E application:

```rust
AppBuilder::new()
    .plugin(Scheduler)                     // scheduler runtime - MUST be before build_state()
    .provide(services.pool.clone())        // provide beans
    .with_producer::<CreatePool>()         // async producer (registers SqlitePool)
    .with_async_bean::<MyAsyncService>()   // async bean constructor
    .with_bean::<UserService>()            // sync bean (unchanged)
    .build_state::<Services, _, _>()       // resolve bean graph (async — .await required)
    .await
    .with_config(config)
    .with(Health)                          // /health → 200 "OK"
    .with(Cors::permissive())              // or Cors::new(custom_layer)
    .with(Tracing)
    .with(ErrorHandling)                   // catch panics → JSON 500
    .with(DevReload)                       // /__r2e_dev/* endpoints
    .with(OpenApiPlugin::new(config))      // /openapi.json (+ /docs if docs_ui enabled)
    .on_start(|state| async move { Ok(()) })
    .on_stop(|| async { })
    .register_controller::<UserController>()
    .register_controller::<AccountController>()
    .register_controller::<ScheduledJobs>() // auto-discovers #[scheduled] methods
    .build()                               // → axum::Router
    // or .serve("0.0.0.0:3000").await     // build + listen + graceful shutdown
```

`build()` returns an `axum::Router`. `serve(addr)` builds, runs startup hooks, registers event consumers, starts scheduled tasks, starts listening, waits for shutdown signal (Ctrl-C / SIGTERM), stops the scheduler, then runs shutdown hooks.

## Testing (r2e-test)

- `TestApp` — wraps an `axum::Router` with an HTTP client for integration testing. Methods: `get`, `post`, `put`, `delete`, `patch` with builder pattern for headers/body.
- `TestResponse` — response wrapper with status, headers, and body helpers.
- `TestJwt` — generates valid JWT tokens for test scenarios with configurable sub/email/roles.

## Configuration (r2e-core)

`R2eConfig` — key-value configuration store loaded from YAML files + environment variable overlay.
- `R2eConfig::load("dev")` — load `application.yaml`, then `application-dev.yaml`, then overlay env vars. Profile overridable via `R2E_PROFILE` env var.
- `R2eConfig::empty()` — empty config for testing.
- `config.set("key", ConfigValue::String("value".into()))` — manual key-value setup.
- `config.get::<T>("key")` — retrieve a typed value (`T: FromConfigValue`).
- `config.get_or("key", default)` — retrieve with fallback.
- `#[config("app.key")]` field attribute on controllers — injected at request time from the config stored in state.
