<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>R2E — Rust Enterprise Edition</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A Quarkus-like ergonomic layer over Axum for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-df6d6725.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-e378e123.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">R2E — Rust Enterprise Edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/plawn/r2e" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>R2E</strong> (Rust Enterprise Edition) is a Quarkus-like ergonomic layer over <a href="https://github.com/tokio-rs/axum">Axum</a> for Rust. It provides declarative controllers, compile-time dependency injection, JWT/OIDC security, and zero runtime reflection.</p>
<h2 id="what-r2e-offers"><a class="header" href="#what-r2e-offers">What R2E offers</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject]           user_service: UserService,
    #[inject(identity)] user: AuthenticatedUser,
    #[config("app.greeting")] greeting: String,
}

#[routes]
#[intercept(Logged::info())]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
        Json(self.user_service.list().await)
    }

    #[post("/")]
    #[roles("admin")]
    #[intercept(CacheInvalidate::group("users"))]
    async fn create(&amp;self, Validated(body): Validated&lt;CreateUserRequest&gt;) -&gt; Json&lt;User&gt; {
        Json(self.user_service.create(body.name, body.email).await)
    }
}
<span class="boring">}</span></code></pre>
<p>If you’ve used Java’s Quarkus, Spring Boot, or C#’s ASP.NET, this should feel familiar — but everything is resolved at compile time with zero runtime reflection.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key features</a></h2>
<ul>
<li><strong>Declarative controllers</strong> — <code>#[derive(Controller)]</code> + <code>#[routes]</code> generate Axum handlers with zero boilerplate</li>
<li><strong>Compile-time DI</strong> — <code>#[inject]</code> for services, <code>#[inject(identity)]</code> for request-scoped identity, <code>#[config("key")]</code> for configuration</li>
<li><strong>JWT/OIDC security</strong> — <code>AuthenticatedUser</code> extractor with JWKS caching, role-based access via <code>#[roles("admin")]</code></li>
<li><strong>Guards</strong> — Pre-auth and post-auth guards for custom authorization logic</li>
<li><strong>Interceptors</strong> — AOP-style <code>#[intercept(...)]</code> for logging, timing, caching, and custom cross-cutting concerns</li>
<li><strong>Rate limiting</strong> — Token-bucket rate limiting per user, per IP, or global</li>
<li><strong>Event bus</strong> — Typed in-process pub/sub with <code>#[consumer]</code> for declarative event handlers</li>
<li><strong>Scheduling</strong> — <code>#[scheduled(every = 30)]</code> and <code>#[scheduled(cron = "...")]</code> for background tasks</li>
<li><strong>Managed resources</strong> — <code>#[managed]</code> for automatic transaction lifecycle</li>
<li><strong>Data access</strong> — <code>Entity</code>, <code>Repository</code>, <code>QueryBuilder</code>, and <code>Pageable</code>/<code>Page</code></li>
<li><strong>Validation</strong> — <code>Validated&lt;T&gt;</code> extractor backed by the <code>validator</code> crate</li>
<li><strong>OpenAPI</strong> — Auto-generated OpenAPI 3.0.3 spec with interactive docs UI</li>
<li><strong>Configuration</strong> — YAML + env var overlay with profile support</li>
<li><strong>SSE &amp; WebSocket</strong> — Built-in <code>SseBroadcaster</code> and <code>WsRooms</code> for real-time communication</li>
<li><strong>Testing</strong> — <code>TestApp</code> HTTP client wrapper and <code>TestJwt</code> token generator</li>
<li><strong>CLI</strong> — <code>r2e new</code>, <code>r2e add</code>, <code>r2e dev</code>, <code>r2e generate</code> for scaffolding</li>
</ul>
<h2 id="how-this-book-is-organized"><a class="header" href="#how-this-book-is-organized">How this book is organized</a></h2>
<ul>
<li><strong>Getting Started</strong> — Install R2E, create your first app, learn the project structure</li>
<li><strong>Core Concepts</strong> — Controllers, DI, beans, plugins, configuration, error handling</li>
<li><strong>Security</strong> — JWT authentication, guards, roles, rate limiting</li>
<li><strong>Data Access</strong> — Entities, repositories, queries, pagination, transactions</li>
<li><strong>Events and Scheduling</strong> — Event bus, consumers, background tasks</li>
<li><strong>Advanced</strong> — Interceptors, custom guards/plugins, managed resources, lifecycle hooks, OpenAPI, performance</li>
<li><strong>Testing</strong> — TestApp, TestJwt, integration patterns</li>
<li><strong>Reference</strong> — Crate map, CLI reference, API docs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong> (stable, 1.75+) — install via <a href="https://rustup.rs/">rustup</a></li>
<li><strong>Cargo</strong> — included with Rust</li>
</ul>
<h2 id="adding-r2e-to-a-project"><a class="header" href="#adding-r2e-to-a-project">Adding R2E to a project</a></h2>
<p>Add R2E and its common dependencies to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
r2e = { version = "0.1", features = ["full", "validation"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
</code></pre>
<p>The <code>"full"</code> feature enables all R2E sub-crates (security, events, scheduler, data, cache, rate-limit, openapi, utils). You can also pick individual features:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["security", "data", "openapi"] }
</code></pre>
<h3 id="available-features"><a class="header" href="#available-features">Available features</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>security</code></td><td>JWT/OIDC authentication (<code>r2e-security</code>)</td></tr>
<tr><td><code>events</code></td><td>In-process event bus (<code>r2e-events</code>)</td></tr>
<tr><td><code>scheduler</code></td><td>Background task scheduling (<code>r2e-scheduler</code>)</td></tr>
<tr><td><code>data</code></td><td>Data access abstractions (<code>r2e-data</code>, <code>r2e-data-sqlx</code>)</td></tr>
<tr><td><code>cache</code></td><td>TTL cache with pluggable backends (<code>r2e-cache</code>)</td></tr>
<tr><td><code>rate-limit</code></td><td>Token-bucket rate limiting (<code>r2e-rate-limit</code>)</td></tr>
<tr><td><code>openapi</code></td><td>OpenAPI 3.0.3 spec generation (<code>r2e-openapi</code>)</td></tr>
<tr><td><code>utils</code></td><td>Built-in interceptors: Logged, Timed, Cache (<code>r2e-utils</code>)</td></tr>
<tr><td><code>validation</code></td><td><code>Validated&lt;T&gt;</code> extractor (<code>validator</code> crate integration)</td></tr>
<tr><td><code>full</code></td><td>Enables all features above</td></tr>
</tbody>
</table>
</div>
<h2 id="installing-the-cli-optional"><a class="header" href="#installing-the-cli-optional">Installing the CLI (optional)</a></h2>
<p>The <code>r2e</code> CLI provides scaffolding and development commands:</p>
<pre><code class="language-bash">cargo install r2e-cli
</code></pre>
<p>This gives you access to:</p>
<ul>
<li><code>r2e new &lt;name&gt;</code> — scaffold a new project</li>
<li><code>r2e dev</code> — start a development server with hot-reload</li>
<li><code>r2e generate</code> — generate controllers, services, and CRUD scaffolds</li>
<li><code>r2e doctor</code> — check your project setup</li>
<li><code>r2e routes</code> — list all registered routes</li>
</ul>
<h2 id="quick-verification"><a class="header" href="#quick-verification">Quick verification</a></h2>
<p>After installing, verify everything works:</p>
<pre><code class="language-bash"># Create a new project
r2e new hello-r2e

# Enter the project
cd hello-r2e

# Run the app
cargo run
</code></pre>
<p>You should see the server start on <code>http://localhost:8080</code>. Visit <code>http://localhost:8080/</code> to see “Hello, World!” and <code>http://localhost:8080/health</code> for the health check.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-app"><a class="header" href="#your-first-app">Your First App</a></h1>
<p>This guide walks you through building a simple REST API with R2E from scratch.</p>
<h2 id="1-create-the-project"><a class="header" href="#1-create-the-project">1. Create the project</a></h2>
<pre><code class="language-bash">cargo new my-api
cd my-api
</code></pre>
<p>Add dependencies to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
r2e = { version = "0.1" }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
</code></pre>
<h2 id="2-define-your-state"><a class="header" href="#2-define-your-state">2. Define your state</a></h2>
<p>Create <code>src/state.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub config: R2eConfig,
}
<span class="boring">}</span></code></pre>
<p><code>BeanState</code> derives the <code>FromRef</code> implementations needed for Axum’s state extraction.</p>
<h2 id="3-create-a-controller"><a class="header" href="#3-create-a-controller">3. Create a controller</a></h2>
<p>Create <code>src/controllers/mod.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod hello;
<span class="boring">}</span></code></pre>
<p>Create <code>src/controllers/hello.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::AppState;
use r2e::prelude::*;

#[derive(Controller)]
#[controller(path = "/hello", state = AppState)]
pub struct HelloController;

#[routes]
impl HelloController {
    #[get("/")]
    async fn hello(&amp;self) -&gt; &amp;'static str {
        "Hello, R2E!"
    }

    #[get("/{name}")]
    async fn greet(&amp;self, Path(name): Path&lt;String&gt;) -&gt; String {
        format!("Hello, {}!", name)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="4-wire-it-up-in-main"><a class="header" href="#4-wire-it-up-in-main">4. Wire it up in main</a></h2>
<p>Replace <code>src/main.rs</code>:</p>
<pre class="playground"><code class="language-rust">use r2e::prelude::*;
use r2e::plugins::{Health, Tracing};

mod controllers;
mod state;

use controllers::hello::HelloController;
use state::AppState;

#[tokio::main]
async fn main() {
    r2e::init_tracing();

    AppBuilder::new()
        .build_state::&lt;AppState, _&gt;()
        .await
        .with(Health)
        .with(Tracing)
        .register_controller::&lt;HelloController&gt;()
        .serve("0.0.0.0:3000")
        .await
        .unwrap();
}</code></pre>
<h2 id="5-run-it"><a class="header" href="#5-run-it">5. Run it</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Test with curl:</p>
<pre><code class="language-bash">curl http://localhost:3000/hello
# Hello, R2E!

curl http://localhost:3000/hello/World
# Hello, World!

curl http://localhost:3000/health
# OK
</code></pre>
<h2 id="adding-a-service"><a class="header" href="#adding-a-service">Adding a service</a></h2>
<p>Let’s add a simple in-memory user service. Create <code>src/services.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use r2e::prelude::*;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
}

#[derive(Clone)]
pub struct UserService {
    users: Arc&lt;RwLock&lt;Vec&lt;User&gt;&gt;&gt;,
}

#[bean]
impl UserService {
    pub fn new() -&gt; Self {
        Self {
            users: Arc::new(RwLock::new(vec![
                User { id: 1, name: "Alice".into() },
                User { id: 2, name: "Bob".into() },
            ])),
        }
    }

    pub async fn list(&amp;self) -&gt; Vec&lt;User&gt; {
        self.users.read().await.clone()
    }

    pub async fn create(&amp;self, name: String) -&gt; User {
        let mut users = self.users.write().await;
        let id = users.len() as u64 + 1;
        let user = User { id, name };
        users.push(user.clone());
        user
    }
}
<span class="boring">}</span></code></pre>
<p>Create <code>src/controllers/user.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::AppState;
use crate::services::{User, UserService};
use r2e::prelude::*;

#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] user_service: UserService,
}

#[routes]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
        Json(self.user_service.list().await)
    }

    #[post("/")]
    async fn create(&amp;self, Json(body): Json&lt;serde_json::Value&gt;) -&gt; Json&lt;User&gt; {
        let name = body["name"].as_str().unwrap_or("Anonymous").to_string();
        Json(self.user_service.create(name).await)
    }
}
<span class="boring">}</span></code></pre>
<p>Update <code>src/state.rs</code> to include the service:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;
use crate::services::UserService;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub user_service: UserService,
    pub config: R2eConfig,
}
<span class="boring">}</span></code></pre>
<p>Update <code>src/controllers/mod.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod hello;
pub mod user;
<span class="boring">}</span></code></pre>
<p>Update <code>src/main.rs</code>:</p>
<pre class="playground"><code class="language-rust">use r2e::prelude::*;
use r2e::plugins::{Health, Tracing};

mod controllers;
mod services;
mod state;

use controllers::hello::HelloController;
use controllers::user::UserController;
use state::AppState;

#[tokio::main]
async fn main() {
    r2e::init_tracing();

    AppBuilder::new()
        .with_bean::&lt;services::UserService&gt;()
        .build_state::&lt;AppState, _&gt;()
        .await
        .with(Health)
        .with(Tracing)
        .register_controller::&lt;HelloController&gt;()
        .register_controller::&lt;UserController&gt;()
        .serve("0.0.0.0:3000")
        .await
        .unwrap();
}</code></pre>
<p>Test:</p>
<pre><code class="language-bash">curl http://localhost:3000/users
# [{"id":1,"name":"Alice"},{"id":2,"name":"Bob"}]

curl -X POST http://localhost:3000/users -H "Content-Type: application/json" -d '{"name":"Charlie"}'
# {"id":3,"name":"Charlie"}
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<ul>
<li><a href="#cli-scaffolding">CLI Scaffolding</a> — use <code>r2e new</code> for faster project setup</li>
<li><a href="#controllers-2">Controllers</a> — learn all controller features</li>
<li><a href="#dependency-injection">Dependency Injection</a> — understand injection scopes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-scaffolding"><a class="header" href="#cli-scaffolding">CLI Scaffolding</a></h1>
<p>The <code>r2e</code> CLI generates project scaffolds and code templates, saving you from writing boilerplate.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a new project</a></h2>
<pre><code class="language-bash">r2e new my-app
</code></pre>
<p>In interactive mode, you’ll be prompted to choose:</p>
<ul>
<li><strong>Database</strong>: None, SQLite, PostgreSQL, or MySQL</li>
<li><strong>Features</strong>: Authentication, OpenAPI, Events, Scheduling</li>
</ul>
<p>Or use flags directly:</p>
<pre><code class="language-bash"># Full-featured project with SQLite
r2e new my-app --full

# PostgreSQL with auth and OpenAPI
r2e new my-app --db postgres --auth --openapi

# Minimal project with no interactive prompts
r2e new my-app --no-interactive
</code></pre>
<h3 id="generated-structure"><a class="header" href="#generated-structure">Generated structure</a></h3>
<pre><code>my-app/
  Cargo.toml
  application.yaml
  src/
    main.rs
    state.rs
    controllers/
      mod.rs
      hello.rs
</code></pre>
<p>With <code>--db</code>, you also get a <code>migrations/</code> directory. With <code>--auth</code>, the state includes a <code>JwtClaimsValidator</code>. With <code>--openapi</code>, the builder includes <code>OpenApiPlugin</code>.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h2>
<h3 id="controllers"><a class="header" href="#controllers">Controllers</a></h3>
<pre><code class="language-bash">r2e generate controller UserController
</code></pre>
<p>Generates <code>src/controllers/user_controller.rs</code> with a skeleton controller and updates <code>src/controllers/mod.rs</code>.</p>
<h3 id="services"><a class="header" href="#services">Services</a></h3>
<pre><code class="language-bash">r2e generate service UserService
</code></pre>
<p>Generates <code>src/user_service.rs</code> with a skeleton service struct.</p>
<h3 id="crud-scaffolding"><a class="header" href="#crud-scaffolding">CRUD scaffolding</a></h3>
<pre><code class="language-bash">r2e generate crud Article --fields "title:String body:String published:bool"
</code></pre>
<p>Generates a complete CRUD set:</p>
<ul>
<li><code>src/models/article.rs</code> — entity struct + <code>CreateArticle</code>/<code>UpdateArticle</code> request types</li>
<li><code>src/services/article_service.rs</code> — service with list/get/create/update/delete</li>
<li><code>src/controllers/article_controller.rs</code> — REST controller (GET, POST, PUT, DELETE)</li>
<li><code>migrations/&lt;timestamp&gt;_create_articles.sql</code> — SQL migration (if <code>migrations/</code> exists)</li>
<li><code>tests/article_test.rs</code> — integration test skeleton</li>
</ul>
<h3 id="middleware-interceptors"><a class="header" href="#middleware-interceptors">Middleware (interceptors)</a></h3>
<pre><code class="language-bash">r2e generate middleware AuditLog
</code></pre>
<p>Generates <code>src/middleware/audit_log.rs</code> with an <code>Interceptor&lt;R&gt;</code> implementation skeleton.</p>
<h2 id="development-server"><a class="header" href="#development-server">Development server</a></h2>
<pre><code class="language-bash">r2e dev
</code></pre>
<p>Wraps <code>cargo watch</code> with R2E defaults:</p>
<ul>
<li>Watches <code>src/</code>, <code>application.yaml</code>, <code>application-dev.yaml</code>, <code>migrations/</code></li>
<li>Sets <code>R2E_PROFILE=dev</code></li>
<li>Prints discovered routes before starting</li>
</ul>
<p>Use <code>--open</code> to auto-open the browser:</p>
<pre><code class="language-bash">r2e dev --open
</code></pre>
<p>Requires <code>cargo-watch</code>: <code>cargo install cargo-watch</code>.</p>
<h2 id="project-health-check"><a class="header" href="#project-health-check">Project health check</a></h2>
<pre><code class="language-bash">r2e doctor
</code></pre>
<p>Runs diagnostics:</p>
<ul>
<li>Cargo.toml exists and has R2E dependency</li>
<li>Configuration file present</li>
<li>Controllers directory exists</li>
<li>Rust toolchain available</li>
<li><code>cargo-watch</code> installed (for <code>r2e dev</code>)</li>
<li>Migrations directory (if using data features)</li>
<li>Application entrypoint has <code>.serve()</code> call</li>
</ul>
<h2 id="route-listing"><a class="header" href="#route-listing">Route listing</a></h2>
<pre><code class="language-bash">r2e routes
</code></pre>
<p>Displays all routes from your controllers (parsed from source, no compilation needed):</p>
<pre><code>GET     /health
GET     /users
GET     /users/{id}
POST    /users               [roles: admin]
DELETE  /users/{id}          [roles: admin]
</code></pre>
<h2 id="extension-management"><a class="header" href="#extension-management">Extension management</a></h2>
<pre><code class="language-bash">r2e add security    # adds r2e-security
r2e add data        # adds r2e-data + r2e-data-sqlx
r2e add openapi     # adds r2e-openapi
r2e add events      # adds r2e-events
r2e add scheduler   # adds r2e-scheduler
r2e add cache       # adds r2e-cache
r2e add rate-limit  # adds r2e-rate-limit
r2e add utils       # adds r2e-utils
r2e add test        # adds r2e-test (dev-dependency)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>A typical R2E project follows this layout:</p>
<pre><code>my-app/
├── Cargo.toml
├── application.yaml              # Base configuration
├── application-dev.yaml          # Dev profile overrides
├── application-prod.yaml         # Prod profile overrides
├── migrations/                   # SQL migrations (if using data features)
│   └── 20250101000001_init.sql
├── src/
│   ├── main.rs                   # Application entry point
│   ├── state.rs                  # AppState definition
│   ├── error.rs                  # Custom error type (optional)
│   ├── models/
│   │   ├── mod.rs
│   │   └── user.rs               # Entity definitions, request/response types
│   ├── services/
│   │   ├── mod.rs
│   │   └── user_service.rs       # Business logic
│   ├── controllers/
│   │   ├── mod.rs
│   │   └── user_controller.rs    # HTTP handlers
│   └── middleware/                # Custom interceptors (optional)
│       ├── mod.rs
│       └── audit_log.rs
└── tests/
    └── user_test.rs              # Integration tests
</code></pre>
<h2 id="key-files"><a class="header" href="#key-files">Key files</a></h2>
<h3 id="mainrs--application-entry-point"><a class="header" href="#mainrs--application-entry-point"><code>main.rs</code> — Application entry point</a></h3>
<p>The main function assembles the application using <code>AppBuilder</code>:</p>
<pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    r2e::init_tracing();

    let config = R2eConfig::load("dev").unwrap_or_else(|_| R2eConfig::empty());

    AppBuilder::new()
        .with_bean::&lt;UserService&gt;()
        .build_state::&lt;AppState, _&gt;()
        .await
        .with_config(config)
        .with(Health)
        .with(Cors::permissive())
        .with(Tracing)
        .with(ErrorHandling)
        .register_controller::&lt;UserController&gt;()
        .serve("0.0.0.0:3000")
        .await
        .unwrap();
}</code></pre>
<h3 id="staters--application-state"><a class="header" href="#staters--application-state"><code>state.rs</code> — Application state</a></h3>
<p>The state struct holds all app-scoped dependencies. <code>BeanState</code> derives <code>FromRef</code> for each field:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, BeanState)]
pub struct AppState {
    pub user_service: UserService,
    pub pool: SqlitePool,
    pub event_bus: EventBus,
    pub config: R2eConfig,
}
<span class="boring">}</span></code></pre>
<h3 id="controllers-1"><a class="header" href="#controllers-1">Controllers</a></h3>
<p>Controllers are structs with <code>#[derive(Controller)]</code> and an impl block with <code>#[routes]</code>. Each method becomes an Axum handler:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] user_service: UserService,
}

#[routes]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { ... }
}
<span class="boring">}</span></code></pre>
<h3 id="services-1"><a class="header" href="#services-1">Services</a></h3>
<p>Services contain business logic and are injected into controllers via <code>#[inject]</code>. Use <code>#[bean]</code> on the impl block to register with the DI system:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct UserService { ... }

#[bean]
impl UserService {
    pub fn new(pool: SqlitePool) -&gt; Self { ... }
}
<span class="boring">}</span></code></pre>
<h3 id="models"><a class="header" href="#models">Models</a></h3>
<p>Model files define data types: entities (database-mapped), request/response DTOs, and events:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Serialize, Deserialize)]
pub struct User { pub id: i64, pub name: String }

#[derive(Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 1))]
    pub name: String,
}
<span class="boring">}</span></code></pre>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration files</a></h3>
<p>YAML files with profile-based overrides and env var overlay:</p>
<pre><code class="language-yaml"># application.yaml — base config
app:
  name: "my-app"
database:
  url: "sqlite:data.db"

# application-dev.yaml — dev overrides
database:
  url: "sqlite::memory:"
</code></pre>
<h2 id="convention-over-configuration"><a class="header" href="#convention-over-configuration">Convention over configuration</a></h2>
<p>R2E follows a few conventions:</p>
<ul>
<li>Controllers live in <code>src/controllers/</code> and are registered explicitly via <code>register_controller::&lt;T&gt;()</code></li>
<li>Services live in <code>src/services/</code> and are registered as beans via <code>with_bean::&lt;T&gt;()</code></li>
<li>Configuration is loaded from <code>application.yaml</code> (with optional profile overrides)</li>
<li>The state struct uses <code>#[derive(BeanState)]</code> for automatic <code>FromRef</code> implementations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="controllers-2"><a class="header" href="#controllers-2">Controllers</a></h1>
<p>Controllers are the central building block of R2E. They map HTTP routes to handler methods with compile-time dependency injection.</p>
<h2 id="declaring-a-controller"><a class="header" href="#declaring-a-controller">Declaring a controller</a></h2>
<p>A controller requires two macros working together:</p>
<ol>
<li><code>#[derive(Controller)]</code> on the struct — generates the Axum extractor and metadata</li>
<li><code>#[routes]</code> on the impl block — generates Axum handler functions and route registration</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] user_service: UserService,
}

#[routes]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
        Json(self.user_service.list().await)
    }

    #[get("/{id}")]
    async fn get_by_id(&amp;self, Path(id): Path&lt;u64&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
        self.user_service.get_by_id(id).await
            .map(Json)
            .ok_or_else(|| AppError::NotFound("User not found".into()))
    }

    #[post("/")]
    async fn create(&amp;self, Json(body): Json&lt;CreateUserRequest&gt;) -&gt; Json&lt;User&gt; {
        Json(self.user_service.create(body.name, body.email).await)
    }

    #[put("/{id}")]
    async fn update(&amp;self, Path(id): Path&lt;u64&gt;, Json(body): Json&lt;UpdateUserRequest&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
        self.user_service.update(id, body).await
            .map(Json)
            .ok_or_else(|| AppError::NotFound("User not found".into()))
    }

    #[delete("/{id}")]
    async fn delete(&amp;self, Path(id): Path&lt;u64&gt;) -&gt; Result&lt;(), AppError&gt; {
        self.user_service.delete(id).await
    }
}
<span class="boring">}</span></code></pre>
<h2 id="controller-attributes"><a class="header" href="#controller-attributes">Controller attributes</a></h2>
<p>The <code>#[controller]</code> attribute takes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td>No</td><td>URL prefix for all routes (default: <code>""</code>)</td></tr>
<tr><td><code>state</code></td><td>Yes</td><td>The application state type</td></tr>
</tbody>
</table>
</div>
<h2 id="http-method-attributes"><a class="header" href="#http-method-attributes">HTTP method attributes</a></h2>
<p>Mark handler methods with the HTTP method they respond to:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>HTTP Method</th></tr>
</thead>
<tbody>
<tr><td><code>#[get("/path")]</code></td><td>GET</td></tr>
<tr><td><code>#[post("/path")]</code></td><td>POST</td></tr>
<tr><td><code>#[put("/path")]</code></td><td>PUT</td></tr>
<tr><td><code>#[delete("/path")]</code></td><td>DELETE</td></tr>
<tr><td><code>#[patch("/path")]</code></td><td>PATCH</td></tr>
</tbody>
</table>
</div>
<p>Path parameters use <code>{name}</code> syntax and are extracted via Axum’s <code>Path</code> extractor.</p>
<h2 id="handler-parameters"><a class="header" href="#handler-parameters">Handler parameters</a></h2>
<p>Handler methods receive the controller instance as <code>&amp;self</code> plus any Axum extractors:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/{id}/comments")]
async fn add_comment(
    &amp;self,
    Path(id): Path&lt;u64&gt;,                    // Path parameter
    Json(body): Json&lt;CreateCommentRequest&gt;,  // JSON body
    Query(params): Query&lt;PaginationParams&gt;,  // Query string
    headers: HeaderMap,                      // Headers
) -&gt; Result&lt;Json&lt;Comment&gt;, AppError&gt; {
    // ...
}
<span class="boring">}</span></code></pre>
<h2 id="injection-scopes"><a class="header" href="#injection-scopes">Injection scopes</a></h2>
<p>Controller fields support three injection scopes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject]              user_service: UserService,     // App-scoped (from state)
    #[inject(identity)]    user: AuthenticatedUser,       // Request-scoped (from request)
    #[config("app.name")]  app_name: String,              // Config-scoped (from R2eConfig)
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scope</th><th>Attribute</th><th>Timing</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>App</td><td><code>#[inject]</code></td><td>Per request</td><td>Cloned from state. Must be <code>Clone + Send + Sync</code>.</td></tr>
<tr><td>Request</td><td><code>#[inject(identity)]</code></td><td>Per request</td><td>Extracted from request parts. Must implement <code>Identity</code>.</td></tr>
<tr><td>Config</td><td><code>#[config("key")]</code></td><td>Per request</td><td>Looked up from <code>R2eConfig</code>.</td></tr>
</tbody>
</table>
</div>
<h2 id="mixed-controllers-param-level-identity"><a class="header" href="#mixed-controllers-param-level-identity">Mixed controllers (param-level identity)</a></h2>
<p>When only some endpoints need authentication, use param-level <code>#[inject(identity)]</code> instead of struct-level:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/api", state = AppState)]
pub struct ApiController {
    #[inject] service: MyService,
}

#[routes]
impl ApiController {
    // Public endpoint — no JWT validation
    #[get("/public")]
    async fn public_data(&amp;self) -&gt; Json&lt;Vec&lt;Data&gt;&gt; {
        Json(self.service.public_list().await)
    }

    // Protected endpoint — JWT validated only for this handler
    #[get("/me")]
    async fn me(&amp;self, #[inject(identity)] user: AuthenticatedUser) -&gt; Json&lt;AuthenticatedUser&gt; {
        Json(user)
    }

    // Optional identity — works with or without auth
    #[get("/greeting")]
    async fn greeting(&amp;self, #[inject(identity)] user: Option&lt;AuthenticatedUser&gt;) -&gt; String {
        match user {
            Some(u) =&gt; format!("Hello, {}!", u.sub),
            None =&gt; "Hello, stranger!".to_string(),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>This is the <strong>mixed controller pattern</strong> — it’s more efficient because JWT validation only runs on endpoints that need it. It also preserves <code>StatefulConstruct</code>, enabling the controller to be used with <code>#[consumer]</code> and <code>#[scheduled]</code>.</p>
<h2 id="registering-controllers"><a class="header" href="#registering-controllers">Registering controllers</a></h2>
<p>Controllers are registered with the application builder:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .register_controller::&lt;UserController&gt;()
    .register_controller::&lt;AccountController&gt;()
    .serve("0.0.0.0:3000")
    .await
    .unwrap();
<span class="boring">}</span></code></pre>
<h2 id="what-gets-generated"><a class="header" href="#what-gets-generated">What gets generated</a></h2>
<p>Behind the scenes, <code>#[derive(Controller)]</code> and <code>#[routes]</code> generate:</p>
<ol>
<li><strong>Metadata module</strong> (<code>__r2e_meta_&lt;Name&gt;</code>) — state type, identity type, path prefix</li>
<li><strong>Extractor struct</strong> (<code>__R2eExtract_&lt;Name&gt;</code>) — implements <code>FromRequestParts</code> to construct the controller</li>
<li><strong>StatefulConstruct impl</strong> — when no struct-level <code>#[inject(identity)]</code> fields exist</li>
<li><strong>Handler functions</strong> — standalone async functions for each route</li>
<li><strong>Controller trait impl</strong> — wires routes into <code>axum::Router&lt;State&gt;</code></li>
</ol>
<p>All of this is hidden from your code — you just write the struct and methods.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency Injection</a></h1>
<p>R2E uses compile-time dependency injection — no runtime reflection, no trait objects, no service locator. All dependencies are resolved at compile time through Rust’s type system.</p>
<h2 id="three-injection-scopes"><a class="header" href="#three-injection-scopes">Three injection scopes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Scope</th><th>Mechanism</th><th>Cost per request</th></tr>
</thead>
<tbody>
<tr><td><code>#[inject]</code></td><td>App</td><td><code>state.field.clone()</code></td><td>~10-50 ns (Arc)</td></tr>
<tr><td><code>#[inject(identity)]</code></td><td>Request</td><td><code>FromRequestParts</code></td><td>~10-50 us (JWT)</td></tr>
<tr><td><code>#[config("key")]</code></td><td>Config</td><td><code>config.get(key)</code></td><td>~50 ns</td></tr>
</tbody>
</table>
</div>
<h3 id="inject--app-scoped"><a class="header" href="#inject--app-scoped"><code>#[inject]</code> — App-scoped</a></h3>
<p>Clones the field from the Axum state. The type must exist as a field in your state struct and implement <code>Clone + Send + Sync</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] user_service: UserService,
    #[inject] pool: SqlitePool,
}
<span class="boring">}</span></code></pre>
<p><strong>Tip:</strong> Wrap services in <code>Arc</code> for cheap clones (reference count increment instead of deep copy).</p>
<h3 id="injectidentity--request-scoped"><a class="header" href="#injectidentity--request-scoped"><code>#[inject(identity)]</code> — Request-scoped</a></h3>
<p>Extracts identity from the HTTP request (typically a JWT bearer token). The type must implement <code>Identity</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject(identity)] user: AuthenticatedUser,
}
<span class="boring">}</span></code></pre>
<p>When placed on a struct field, <strong>every</strong> handler in the controller requires authentication. For selective auth, use <a href="#mixed-controllers-param-level-identity">param-level identity</a>.</p>
<h3 id="configkey--config-scoped"><a class="header" href="#configkey--config-scoped"><code>#[config("key")]</code> — Config-scoped</a></h3>
<p>Resolves a value from <code>R2eConfig</code> at request time. Supported types: <code>String</code>, <code>i64</code>, <code>f64</code>, <code>bool</code>, <code>Option&lt;T&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[config("app.greeting")] greeting: String,
    #[config("app.max-retries")] max_retries: i64,
    #[config("app.optional-key")] maybe: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre>
<p>Missing required config keys panic at request time with a message including the environment variable equivalent (e.g., <code>APP_GREETING</code>).</p>
<h2 id="statefulconstruct"><a class="header" href="#statefulconstruct">StatefulConstruct</a></h2>
<p>When a controller has no struct-level <code>#[inject(identity)]</code> fields, R2E generates a <code>StatefulConstruct&lt;S&gt;</code> implementation. This allows constructing the controller from state alone (without an HTTP request), which is required for:</p>
<ul>
<li><strong>Event consumers</strong> (<code>#[consumer]</code>) — handle events outside HTTP context</li>
<li><strong>Scheduled tasks</strong> (<code>#[scheduled]</code>) — run background jobs</li>
</ul>
<p>Controllers with struct-level <code>#[inject(identity)]</code> fields do <strong>not</strong> get <code>StatefulConstruct</code> — attempting to use them for consumers or scheduled tasks produces a compile error.</p>
<p>The <a href="#mixed-controllers-param-level-identity">mixed controller pattern</a> (param-level <code>#[inject(identity)]</code>) preserves <code>StatefulConstruct</code> while still supporting authentication on individual endpoints.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="state-and-beans"><a class="header" href="#state-and-beans">State and Beans</a></h1>
<p>R2E’s dependency injection is built on a bean graph — a set of factories that produce your application services in dependency order.</p>
<h2 id="application-state"><a class="header" href="#application-state">Application state</a></h2>
<p>Your state struct holds all app-scoped dependencies. Derive <code>BeanState</code> to generate <code>FromRef</code> implementations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub user_service: UserService,
    pub pool: SqlitePool,
    pub event_bus: EventBus,
    pub config: R2eConfig,
}
<span class="boring">}</span></code></pre>
<h2 id="bean-traits"><a class="header" href="#bean-traits">Bean traits</a></h2>
<p>R2E provides three bean traits for registering services:</p>
<h3 id="bean--synchronous-construction"><a class="header" href="#bean--synchronous-construction"><code>Bean</code> — Synchronous construction</a></h3>
<p>For services with simple, synchronous initialization:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct UserService {
    pool: SqlitePool,
    event_bus: EventBus,
}

#[bean]
impl UserService {
    pub fn new(pool: SqlitePool, event_bus: EventBus) -&gt; Self {
        Self { pool, event_bus }
    }
}
<span class="boring">}</span></code></pre>
<p>Register with <code>.with_bean::&lt;UserService&gt;()</code>.</p>
<h3 id="asyncbean--asynchronous-construction"><a class="header" href="#asyncbean--asynchronous-construction"><code>AsyncBean</code> — Asynchronous construction</a></h3>
<p>For services that need async initialization (e.g., database connections):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct CacheService {
    client: RedisClient,
}

#[bean]
impl CacheService {
    pub async fn new(#[config("cache.url")] url: String) -&gt; Self {
        let client = RedisClient::connect(&amp;url).await.unwrap();
        Self { client }
    }
}
<span class="boring">}</span></code></pre>
<p>Register with <code>.with_async_bean::&lt;CacheService&gt;()</code>. The <code>#[bean]</code> macro auto-detects async constructors and generates <code>impl AsyncBean</code> instead of <code>impl Bean</code>.</p>
<h3 id="producer--factory-for-types-you-dont-own"><a class="header" href="#producer--factory-for-types-you-dont-own"><code>Producer</code> — Factory for types you don’t own</a></h3>
<p>For types from external crates (e.g., connection pools):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[producer]
async fn create_pool(#[config("database.url")] url: String) -&gt; SqlitePool {
    SqlitePool::connect(&amp;url).await.unwrap()
}
<span class="boring">}</span></code></pre>
<p>This generates a struct <code>CreatePool</code> with <code>impl Producer</code>. Register with <code>.with_producer::&lt;CreatePool&gt;()</code>.</p>
<h3 id="derivebean--derive-based-beans"><a class="header" href="#derivebean--derive-based-beans"><code>#[derive(Bean)]</code> — Derive-based beans</a></h3>
<p>For simple structs where the constructor just clones fields from the graph:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Bean)]
pub struct MyService {
    #[inject] event_bus: EventBus,
    #[inject] pool: SqlitePool,
    #[config("app.name")] name: String,
}
<span class="boring">}</span></code></pre>
<h2 id="config-injection-in-beans"><a class="header" href="#config-injection-in-beans">Config injection in beans</a></h2>
<p>Use <code>#[config("key")]</code> on constructor parameters or derive fields to resolve values from <code>R2eConfig</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bean]
impl NotificationService {
    pub fn new(
        bus: EventBus,
        #[config("notification.capacity")] capacity: i64,
        #[config("notification.enabled")] enabled: bool,
    ) -&gt; Self {
        Self { bus, capacity: capacity as usize, enabled }
    }
}
<span class="boring">}</span></code></pre>
<p>When <code>#[config]</code> is used, <code>R2eConfig</code> is automatically added to the bean’s dependency list. Missing keys panic with an error that includes the environment variable equivalent.</p>
<h2 id="building-state"><a class="header" href="#building-state">Building state</a></h2>
<p>The <code>build_state()</code> method resolves the bean graph in dependency order:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .provide(event_bus)                    // provide pre-built instances
    .provide(pool)
    .with_producer::&lt;CreatePool&gt;()         // async producer
    .with_async_bean::&lt;CacheService&gt;()     // async bean
    .with_bean::&lt;UserService&gt;()            // sync bean
    .build_state::&lt;AppState, _&gt;()          // resolve the graph
    .await                                 // async because graph may contain async beans
<span class="boring">}</span></code></pre>
<h3 id="provide-vs-with_bean"><a class="header" href="#provide-vs-with_bean"><code>provide()</code> vs <code>with_bean()</code></a></h3>
<ul>
<li><code>provide(value)</code> — injects a pre-built instance directly into the graph</li>
<li><code>with_bean::&lt;T&gt;()</code> — registers a factory; R2E constructs it from its dependencies</li>
</ul>
<p>Use <code>provide()</code> for values constructed outside the bean graph (e.g., configuration, tokens, pre-existing pools).</p>
<h3 id="resolution-order"><a class="header" href="#resolution-order">Resolution order</a></h3>
<ol>
<li>All <code>provide()</code>d values are available immediately</li>
<li><code>Bean</code> / <code>AsyncBean</code> / <code>Producer</code> factories run in dependency order</li>
<li>If bean A depends on bean B, B is constructed first</li>
<li>Circular dependencies cause a panic at startup</li>
</ol>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete example</a></h2>
<pre class="playground"><code class="language-rust">use r2e::prelude::*;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub user_service: UserService,
    pub notification_service: NotificationService,
    pub pool: SqlitePool,
    pub event_bus: EventBus,
    pub config: R2eConfig,
}

#[producer]
async fn create_pool(#[config("database.url")] url: String) -&gt; SqlitePool {
    SqlitePool::connect(&amp;url).await.unwrap()
}

#[tokio::main]
async fn main() {
    let config = R2eConfig::load("dev").unwrap();
    let event_bus = EventBus::new();

    AppBuilder::new()
        .provide(event_bus)
        .provide(config.clone())
        .with_producer::&lt;CreatePool&gt;()
        .with_bean::&lt;UserService&gt;()
        .with_bean::&lt;NotificationService&gt;()
        .build_state::&lt;AppState, _&gt;()
        .await
        .with_config(config)
        // ... register controllers, plugins, etc.
        .serve("0.0.0.0:3000")
        .await
        .unwrap();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Plugins extend R2E applications with reusable middleware, routes, and services. R2E ships with several built-in plugins and supports custom ones.</p>
<h2 id="built-in-plugins"><a class="header" href="#built-in-plugins">Built-in plugins</a></h2>
<p>Install plugins with <code>.with(plugin)</code> on the builder (after <code>build_state()</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(Health)
    .with(Cors::permissive())
    .with(Tracing)
    .with(ErrorHandling)
    .with(NormalizePath)
    .serve("0.0.0.0:3000")
    .await
    .unwrap();
<span class="boring">}</span></code></pre>
<h3 id="available-plugins"><a class="header" href="#available-plugins">Available plugins</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Plugin</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Health</code></td><td><code>GET /health</code> returning 200 “OK”</td></tr>
<tr><td><code>Cors::permissive()</code></td><td>Permissive CORS headers</td></tr>
<tr><td><code>Cors::new(layer)</code></td><td>Custom CORS configuration</td></tr>
<tr><td><code>Tracing</code></td><td>Request tracing via <code>tracing</code> + <code>tower-http</code></td></tr>
<tr><td><code>ErrorHandling</code></td><td>Catches panics, returns JSON 500</td></tr>
<tr><td><code>NormalizePath</code></td><td>Trailing-slash normalization</td></tr>
<tr><td><code>DevReload</code></td><td>Dev-mode <code>/__r2e_dev/*</code> endpoints</td></tr>
<tr><td><code>RequestIdPlugin</code></td><td>X-Request-Id propagation</td></tr>
<tr><td><code>SecureHeaders</code></td><td>Security headers (X-Content-Type-Options, etc.)</td></tr>
<tr><td><code>OpenApiPlugin</code></td><td>OpenAPI spec + docs UI</td></tr>
<tr><td><code>Prometheus</code></td><td>Prometheus metrics at <code>/metrics</code></td></tr>
</tbody>
</table>
</div>
<h3 id="pre-state-plugins"><a class="header" href="#pre-state-plugins">Pre-state plugins</a></h3>
<p>Some plugins need to install before <code>build_state()</code>. Use <code>.plugin()</code> instead of <code>.with()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .plugin(Scheduler)    // provides CancellationToken to the bean graph
    .build_state::&lt;AppState, _&gt;()
    .await
    // ...
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pre-state Plugin</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Scheduler</code></td><td>Background task scheduling runtime</td></tr>
</tbody>
</table>
</div>
<h2 id="plugin-ordering"><a class="header" href="#plugin-ordering">Plugin ordering</a></h2>
<p>Plugins are installed in registration order. Some have ordering requirements:</p>
<ul>
<li><code>NormalizePath</code> should be installed last (or use <code>should_be_last()</code> hint — R2E warns if plugins are added after it)</li>
<li><code>Tracing</code> should be early to capture all requests</li>
<li><code>ErrorHandling</code> should be after <code>Tracing</code> but before route registration</li>
</ul>
<h2 id="custom-tower-layers"><a class="header" href="#custom-tower-layers">Custom Tower layers</a></h2>
<p>For Tower middleware that doesn’t need the full plugin API, use <code>.with_layer()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tower_http::timeout::TimeoutLayer;

AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with_layer(TimeoutLayer::new(Duration::from_secs(30)))
    // ...
<span class="boring">}</span></code></pre>
<h2 id="writing-custom-plugins"><a class="header" href="#writing-custom-plugins">Writing custom plugins</a></h2>
<h3 id="post-state-plugins"><a class="header" href="#post-state-plugins">Post-state plugins</a></h3>
<p>Implement the <code>Plugin</code> trait for plugins that install after <code>build_state()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::plugin::Plugin;
use axum::Router;

pub struct MyPlugin;

impl&lt;S: Clone + Send + Sync + 'static&gt; Plugin&lt;S&gt; for MyPlugin {
    fn install(self, router: Router&lt;S&gt;) -&gt; Router&lt;S&gt; {
        // Add routes, layers, or middleware
        router.route("/my-endpoint", get(|| async { "Hello from plugin" }))
    }

    fn should_be_last(&amp;self) -&gt; bool {
        false
    }
}
<span class="boring">}</span></code></pre>
<h3 id="pre-state-plugins-1"><a class="header" href="#pre-state-plugins-1">Pre-state plugins</a></h3>
<p>Implement <code>PreStatePlugin</code> for plugins that need to run before <code>build_state()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::plugin::PreStatePlugin;

pub struct MyPreStatePlugin;

impl PreStatePlugin for MyPreStatePlugin {
    fn install(self, builder: &amp;mut AppBuilder) {
        // Store data, register deferred actions, etc.
    }
}
<span class="boring">}</span></code></pre>
<h3 id="deferred-actions"><a class="header" href="#deferred-actions">Deferred actions</a></h3>
<p>For plugins that need to perform setup after state construction, use <code>DeferredAction</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::plugin::{DeferredAction, DeferredContext};

impl PreStatePlugin for MyPlugin {
    fn install(self, builder: &amp;mut AppBuilder) {
        builder.defer(DeferredAction::new("my-plugin", |ctx: &amp;mut DeferredContext| {
            ctx.add_layer(my_layer);
            ctx.on_serve(|| async { /* run when server starts */ });
            ctx.on_shutdown(|| async { /* run when server stops */ });
        }));
    }
}
<span class="boring">}</span></code></pre>
<p><code>DeferredContext</code> provides:</p>
<ul>
<li><code>add_layer()</code> — add a Tower layer</li>
<li><code>store_data()</code> — store data in the builder</li>
<li><code>on_serve()</code> — register a serve hook</li>
<li><code>on_shutdown()</code> — register a shutdown hook</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>R2E uses YAML-based configuration with profile support and environment variable overlay.</p>
<h2 id="configuration-files-1"><a class="header" href="#configuration-files-1">Configuration files</a></h2>
<p>Create <code>application.yaml</code> in your project root:</p>
<pre><code class="language-yaml">app:
  name: "my-app"
  greeting: "Hello"
  max-retries: 3

database:
  url: "sqlite:data.db"

server:
  port: 8080
</code></pre>
<h3 id="profile-overrides"><a class="header" href="#profile-overrides">Profile overrides</a></h3>
<p>Create profile-specific files that override the base config:</p>
<pre><code class="language-yaml"># application-dev.yaml
database:
  url: "sqlite::memory:"

# application-prod.yaml
database:
  url: "${DATABASE_URL}"
server:
  port: 80
</code></pre>
<h3 id="loading-configuration"><a class="header" href="#loading-configuration">Loading configuration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load base + profile overrides
let config = R2eConfig::load("dev").unwrap();

// Profile can be set via R2E_PROFILE env var
let config = R2eConfig::load("dev").unwrap(); // R2E_PROFILE=prod overrides

// Empty config for testing
let config = R2eConfig::empty();
<span class="boring">}</span></code></pre>
<p>Resolution order (later wins):</p>
<ol>
<li><code>application.yaml</code></li>
<li><code>application-{profile}.yaml</code></li>
<li>Environment variables</li>
</ol>
<h2 id="environment-variable-overlay"><a class="header" href="#environment-variable-overlay">Environment variable overlay</a></h2>
<p>Environment variables override any YAML key using the convention: dots become underscores, hyphens become underscores, all uppercase.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>YAML key</th><th>Environment variable</th></tr>
</thead>
<tbody>
<tr><td><code>app.name</code></td><td><code>APP_NAME</code></td></tr>
<tr><td><code>database.url</code></td><td><code>DATABASE_URL</code></td></tr>
<tr><td><code>app.max-retries</code></td><td><code>APP_MAX_RETRIES</code></td></tr>
<tr><td><code>server.port</code></td><td><code>SERVER_PORT</code></td></tr>
</tbody>
</table>
</div>
<h2 id="using-configuration"><a class="header" href="#using-configuration">Using configuration</a></h2>
<h3 id="in-controllers"><a class="header" href="#in-controllers">In controllers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[config("app.greeting")] greeting: String,
    #[config("app.max-retries")] max_retries: i64,
    #[config("feature.enabled")] enabled: bool,
    #[config("optional.key")] maybe: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre>
<p>Supported types: <code>String</code>, <code>i64</code>, <code>f64</code>, <code>bool</code>, <code>Option&lt;T&gt;</code>.</p>
<p>Missing required keys (non-<code>Option</code>) panic at request time with a descriptive message including the env var name.</p>
<h3 id="in-beans"><a class="header" href="#in-beans">In beans</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bean]
impl NotificationService {
    pub fn new(
        bus: EventBus,
        #[config("notification.capacity")] capacity: i64,
    ) -&gt; Self {
        Self { bus, capacity: capacity as usize }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="in-producers"><a class="header" href="#in-producers">In producers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[producer]
async fn create_pool(#[config("database.url")] url: String) -&gt; SqlitePool {
    SqlitePool::connect(&amp;url).await.unwrap()
}
<span class="boring">}</span></code></pre>
<h3 id="programmatic-access"><a class="header" href="#programmatic-access">Programmatic access</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = R2eConfig::load("dev").unwrap();

// Typed access
let name: String = config.get("app.name").unwrap();
let retries: i64 = config.get("app.max-retries").unwrap();

// With default
let port: i64 = config.get_or("server.port", 3000);

// Manual set
config.set("app.key", ConfigValue::String("value".into()));
<span class="boring">}</span></code></pre>
<h2 id="providing-config-to-the-app"><a class="header" href="#providing-config-to-the-app">Providing config to the app</a></h2>
<p>Pass the config to the builder so controllers can access it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = R2eConfig::load("dev").unwrap();

AppBuilder::new()
    .provide(config.clone())
    .build_state::&lt;AppState, _&gt;()
    .await
    .with_config(config)  // makes it available for #[config] fields
    // ...
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>R2E provides a built-in <code>AppError</code> type and supports custom error types that integrate with Axum’s response system.</p>
<h2 id="built-in-apperror"><a class="header" href="#built-in-apperror">Built-in <code>AppError</code></a></h2>
<p><code>AppError</code> maps common error cases to HTTP status codes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::AppError;

#[get("/{id}")]
async fn get_by_id(&amp;self, Path(id): Path&lt;u64&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
    self.service.get_by_id(id).await
        .map(Json)
        .ok_or_else(|| AppError::NotFound("User not found".into()))
}
<span class="boring">}</span></code></pre>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>HTTP Status</th><th>JSON body</th></tr>
</thead>
<tbody>
<tr><td><code>AppError::NotFound(msg)</code></td><td>404</td><td><code>{"error": "User not found"}</code></td></tr>
<tr><td><code>AppError::Unauthorized(msg)</code></td><td>401</td><td><code>{"error": "..."}</code></td></tr>
<tr><td><code>AppError::Forbidden(msg)</code></td><td>403</td><td><code>{"error": "..."}</code></td></tr>
<tr><td><code>AppError::BadRequest(msg)</code></td><td>400</td><td><code>{"error": "..."}</code></td></tr>
<tr><td><code>AppError::Internal(msg)</code></td><td>500</td><td><code>{"error": "..."}</code></td></tr>
<tr><td><code>AppError::Custom { status, body }</code></td><td>any</td><td>custom JSON body</td></tr>
</tbody>
</table>
</div>
<h3 id="custom-status-codes"><a class="header" href="#custom-status-codes">Custom status codes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Result&lt;Json&lt;Response&gt;, AppError&gt; {
    Err(AppError::Custom {
        status: StatusCode::CONFLICT,
        body: serde_json::json!({
            "error": "duplicate_entry",
            "message": "A user with this email already exists",
        }),
    })
}
<span class="boring">}</span></code></pre>
<h2 id="custom-error-types"><a class="header" href="#custom-error-types">Custom error types</a></h2>
<p>For production applications, define your own error type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::response::{IntoResponse, Response};
use axum::http::StatusCode;
use axum::Json;

#[derive(Debug)]
pub enum MyAppError {
    NotFound(String),
    Database(String),
    Validation(String),
    Internal(String),
}

impl IntoResponse for MyAppError {
    fn into_response(self) -&gt; Response {
        let (status, message) = match self {
            MyAppError::NotFound(msg) =&gt; (StatusCode::NOT_FOUND, msg),
            MyAppError::Database(msg) =&gt; (StatusCode::INTERNAL_SERVER_ERROR, msg),
            MyAppError::Validation(msg) =&gt; (StatusCode::BAD_REQUEST, msg),
            MyAppError::Internal(msg) =&gt; (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };
        let body = serde_json::json!({ "error": message });
        (status, Json(body)).into_response()
    }
}

// Automatic conversion from external errors
impl From&lt;sqlx::Error&gt; for MyAppError {
    fn from(err: sqlx::Error) -&gt; Self {
        MyAppError::Database(err.to_string())
    }
}
<span class="boring">}</span></code></pre>
<p>Then use it in handlers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/{id}")]
async fn get_by_id(&amp;self, Path(id): Path&lt;u64&gt;) -&gt; Result&lt;Json&lt;User&gt;, MyAppError&gt; {
    let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = ?", id)
        .fetch_optional(&amp;self.pool)
        .await?;  // ? converts sqlx::Error → MyAppError::Database

    user.map(Json)
        .ok_or_else(|| MyAppError::NotFound(format!("User {} not found", id)))
}
<span class="boring">}</span></code></pre>
<h2 id="panic-catching"><a class="header" href="#panic-catching">Panic catching</a></h2>
<p>Install the <code>ErrorHandling</code> plugin to catch panics and return JSON 500 responses instead of crashing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(ErrorHandling)
    // ...
<span class="boring">}</span></code></pre>
<p>Without this, a panic in a handler will drop the connection with no response.</p>
<h2 id="error-wrappers-for-managed-resources"><a class="header" href="#error-wrappers-for-managed-resources">Error wrappers for managed resources</a></h2>
<p>The <code>ManagedResource</code> trait requires <code>Error: Into&lt;Response&gt;</code>. Due to Rust’s orphan rules, you can’t implement <code>Into&lt;Response&gt;</code> directly for your error type. R2E provides wrappers:</p>
<ul>
<li><code>ManagedError</code> — wraps the built-in <code>AppError</code></li>
<li><code>ManagedErr&lt;E&gt;</code> — wraps any error type implementing <code>IntoResponse</code></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S: HasPool + Send + Sync&gt; ManagedResource&lt;S&gt; for Tx&lt;'static, Sqlite&gt; {
    type Error = ManagedErr&lt;MyAppError&gt;;

    async fn acquire(state: &amp;S) -&gt; Result&lt;Self, Self::Error&gt; {
        let tx = state.pool().begin().await
            .map_err(|e| ManagedErr(MyAppError::Database(e.to_string())))?;
        Ok(Tx(tx))
    }
    // ...
}
<span class="boring">}</span></code></pre>
<p>See <a href="#managed-resources">Managed Resources</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>R2E provides a <code>Validated&lt;T&gt;</code> extractor that validates request bodies using the <code>validator</code> crate.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Enable the <code>validation</code> feature:</p>
<pre><code class="language-toml">[dependencies]
r2e = { version = "0.1", features = ["validation"] }
validator = { version = "0.18", features = ["derive"] }
</code></pre>
<h2 id="defining-validation-rules"><a class="header" href="#defining-validation-rules">Defining validation rules</a></h2>
<p>Derive <code>Validate</code> on your request types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;
use validator::Validate;

#[derive(Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 1, max = 100))]
    pub name: String,

    #[validate(email)]
    pub email: String,

    #[validate(range(min = 0, max = 150))]
    pub age: Option&lt;i32&gt;,

    #[validate(url)]
    pub website: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="available-rules"><a class="header" href="#available-rules">Available rules</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rule</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>length(min = N, max = N)</code></td><td>String length constraints</td></tr>
<tr><td><code>email</code></td><td>Valid email format</td></tr>
<tr><td><code>url</code></td><td>Valid URL format</td></tr>
<tr><td><code>range(min = N, max = N)</code></td><td>Numeric range</td></tr>
<tr><td><code>regex(path = "PATTERN")</code></td><td>Regex match</td></tr>
<tr><td><code>contains(pattern = "str")</code></td><td>String contains substring</td></tr>
<tr><td><code>must_match(other = "field")</code></td><td>Two fields must be equal</td></tr>
<tr><td><code>custom(function = "fn_name")</code></td><td>Custom validation function</td></tr>
</tbody>
</table>
</div>
<h2 id="using-validatedt"><a class="header" href="#using-validatedt">Using <code>Validated&lt;T&gt;</code></a></h2>
<p>Replace <code>Json&lt;T&gt;</code> with <code>Validated&lt;T&gt;</code> in your handler:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;

#[post("/")]
async fn create(&amp;self, Validated(body): Validated&lt;CreateUserRequest&gt;) -&gt; Json&lt;User&gt; {
    Json(self.user_service.create(body.name, body.email).await)
}
<span class="boring">}</span></code></pre>
<p><code>Validated&lt;T&gt;</code> performs two steps:</p>
<ol>
<li>Deserializes the JSON body (returns 400 on parse error)</li>
<li>Runs validation rules (returns 400 with field-level errors)</li>
</ol>
<h2 id="error-response-format"><a class="header" href="#error-response-format">Error response format</a></h2>
<p>On validation failure, R2E returns a 400 response with structured errors:</p>
<pre><code class="language-json">{
  "error": "Validation failed",
  "fields": {
    "name": [
      {
        "code": "length",
        "message": null,
        "params": {
          "min": 1,
          "max": 100,
          "value": ""
        }
      }
    ],
    "email": [
      {
        "code": "email",
        "message": null,
        "params": {
          "value": "not-an-email"
        }
      }
    ]
  }
}
</code></pre>
<h2 id="json-deserialization-errors"><a class="header" href="#json-deserialization-errors">JSON deserialization errors</a></h2>
<p>If the body can’t be deserialized (e.g., wrong types, missing required fields), R2E returns a 400 before validation runs:</p>
<pre><code class="language-json">{
  "error": "Invalid JSON: missing field `name` at line 1 column 2"
}
</code></pre>
<h2 id="custom-validation-functions"><a class="header" href="#custom-validation-functions">Custom validation functions</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_username(username: &amp;str) -&gt; Result&lt;(), validator::ValidationError&gt; {
    if username.contains(' ') {
        return Err(validator::ValidationError::new("no_spaces"));
    }
    Ok(())
}

#[derive(Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(custom(function = "validate_username"))]
    pub username: String,
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jwt--oidc-authentication"><a class="header" href="#jwt--oidc-authentication">JWT / OIDC Authentication</a></h1>
<p>R2E provides JWT-based authentication with support for both static keys and JWKS endpoints (for OIDC providers like Keycloak, Auth0, etc.).</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Enable the security feature:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["security"] }
</code></pre>
<h2 id="configuring-the-validator"><a class="header" href="#configuring-the-validator">Configuring the validator</a></h2>
<h3 id="static-key-testing--simple-setups"><a class="header" href="#static-key-testing--simple-setups">Static key (testing / simple setups)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_security::{JwtClaimsValidator, SecurityConfig};
use jsonwebtoken::DecodingKey;

let config = SecurityConfig::new("unused-jwks-url", "my-issuer", "my-audience");
let key = DecodingKey::from_secret(b"my-secret-key");
let validator = JwtClaimsValidator::new_with_static_key(key, config);
<span class="boring">}</span></code></pre>
<h3 id="jwks-endpoint-production"><a class="header" href="#jwks-endpoint-production">JWKS endpoint (production)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = SecurityConfig::new(
    "https://auth.example.com/.well-known/jwks.json",
    "https://auth.example.com",
    "my-app",
);
let validator = JwtClaimsValidator::new(config);
<span class="boring">}</span></code></pre>
<p>The JWKS keys are fetched and cached automatically. Cache misses trigger a background refresh.</p>
<h2 id="storing-in-application-state"><a class="header" href="#storing-in-application-state">Storing in application state</a></h2>
<p>The validator must be stored as <code>Arc&lt;JwtClaimsValidator&gt;</code> in your state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub claims_validator: Arc&lt;JwtClaimsValidator&gt;,
    // ... other fields
}
<span class="boring">}</span></code></pre>
<p>Then provide it during app assembly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .provide(Arc::new(validator))
    // ...
<span class="boring">}</span></code></pre>
<h2 id="authenticateduser-extractor"><a class="header" href="#authenticateduser-extractor"><code>AuthenticatedUser</code> extractor</a></h2>
<p><code>AuthenticatedUser</code> is an Axum <code>FromRequestParts</code> extractor that validates the JWT bearer token:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_security::AuthenticatedUser;

#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject(identity)] user: AuthenticatedUser,
}

#[routes]
impl UserController {
    #[get("/me")]
    async fn me(&amp;self) -&gt; Json&lt;AuthenticatedUser&gt; {
        Json(self.user.clone())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="available-fields"><a class="header" href="#available-fields">Available fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sub</code></td><td><code>String</code></td><td>Unique subject identifier</td></tr>
<tr><td><code>email</code></td><td><code>Option&lt;String&gt;</code></td><td>Email address</td></tr>
<tr><td><code>roles</code></td><td><code>Vec&lt;String&gt;</code></td><td>Extracted roles</td></tr>
<tr><td><code>claims</code></td><td><code>serde_json::Value</code></td><td>Raw JWT claims</td></tr>
</tbody>
</table>
</div>
<h3 id="utility-methods"><a class="header" href="#utility-methods">Utility methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>user.has_role("admin")           // check single role
user.has_any_role(&amp;["admin", "moderator"])  // check any of roles
<span class="boring">}</span></code></pre>
<h2 id="authentication-flow"><a class="header" href="#authentication-flow">Authentication flow</a></h2>
<ol>
<li>Client sends <code>Authorization: Bearer &lt;token&gt;</code> header</li>
<li>R2E extracts the token</li>
<li>Token signature is validated (static key or JWKS lookup)</li>
<li>Claims are extracted (<code>sub</code>, <code>email</code>, <code>roles</code>)</li>
<li><code>AuthenticatedUser</code> is constructed</li>
<li>If validation fails → 401 Unauthorized (handler never executes)</li>
</ol>
<h2 id="role-extraction"><a class="header" href="#role-extraction">Role extraction</a></h2>
<p>R2E extracts roles from two locations (checked in order):</p>
<ol>
<li>Top-level <code>roles</code> claim: <code>{"roles": ["admin", "user"]}</code></li>
<li>Keycloak format: <code>{"realm_access": {"roles": ["admin", "user"]}}</code></li>
</ol>
<p>This is handled by the <code>DefaultRoleExtractor</code>. Custom extraction can be provided by implementing the <code>RoleExtractor</code> trait.</p>
<h2 id="struct-level-vs-param-level-identity"><a class="header" href="#struct-level-vs-param-level-identity">Struct-level vs param-level identity</a></h2>
<p><strong>Struct-level</strong> — all endpoints require authentication:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject(identity)] user: AuthenticatedUser,
}
<span class="boring">}</span></code></pre>
<p><strong>Param-level</strong> — only annotated endpoints require authentication:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/api", state = AppState)]
pub struct ApiController {
    #[inject] service: MyService,
}

#[routes]
impl ApiController {
    #[get("/public")]
    async fn public_data(&amp;self) -&gt; Json&lt;Data&gt; { /* no auth */ }

    #[get("/me")]
    async fn me(&amp;self, #[inject(identity)] user: AuthenticatedUser) -&gt; Json&lt;User&gt; {
        Json(user)
    }
}
<span class="boring">}</span></code></pre>
<p>Param-level is more efficient — JWT validation only runs on endpoints that need it.</p>
<h2 id="optional-identity"><a class="header" href="#optional-identity">Optional identity</a></h2>
<p>For endpoints that work with or without authentication:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/greeting")]
async fn greeting(
    &amp;self,
    #[inject(identity)] user: Option&lt;AuthenticatedUser&gt;,
) -&gt; String {
    match user {
        Some(u) =&gt; format!("Hello, {}!", u.sub),
        None =&gt; "Hello, stranger!".to_string(),
    }
}
<span class="boring">}</span></code></pre>
<h2 id="configuration-via-yaml"><a class="header" href="#configuration-via-yaml">Configuration via YAML</a></h2>
<pre><code class="language-yaml">security:
  jwt:
    issuer: "https://auth.example.com"
    audience: "my-app"
    jwks-url: "https://auth.example.com/.well-known/jwks.json"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="guards-and-roles"><a class="header" href="#guards-and-roles">Guards and Roles</a></h1>
<p>Guards are authorization checks that run before the handler body. R2E supports role-based access control and custom guards.</p>
<h2 id="role-based-access"><a class="header" href="#role-based-access">Role-based access</a></h2>
<p>Use <code>#[roles("...")]</code> to restrict endpoint access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/admin")]
#[roles("admin")]
async fn admin_only(&amp;self) -&gt; Json&lt;&amp;'static str&gt; {
    Json("secret admin data")
}

// Multiple roles (OR logic — user needs at least one)
#[get("/manage")]
#[roles("admin", "moderator")]
async fn manage(&amp;self) -&gt; Json&lt;&amp;'static str&gt; {
    Json("management panel")
}
<span class="boring">}</span></code></pre>
<p>If the user doesn’t have the required role, a 403 Forbidden response is returned.</p>
<h2 id="the-guard-trait"><a class="header" href="#the-guard-trait">The <code>Guard</code> trait</a></h2>
<p>Custom post-auth guards implement <code>Guard&lt;S, I&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::{Guard, GuardContext, Identity};
use axum::response::{IntoResponse, Response};

struct TenantGuard;

impl&lt;S: Send + Sync, I: Identity&gt; Guard&lt;S, I&gt; for TenantGuard {
    fn check(
        &amp;self,
        state: &amp;S,
        ctx: &amp;GuardContext&lt;'_, I&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            match ctx.identity_claims() {
                Some(claims) if claims["tenant_id"].is_string() =&gt; Ok(()),
                _ =&gt; Err(AppError::Forbidden("Missing tenant".into()).into_response()),
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Apply with <code>#[guard(...)]</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
#[guard(TenantGuard)]
async fn tenant_data(&amp;self) -&gt; Json&lt;Data&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h3 id="guardcontext"><a class="header" href="#guardcontext"><code>GuardContext</code></a></h3>
<p>Guards receive a <code>GuardContext</code> with:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>method_name</code></td><td><code>&amp;str</code></td><td>Handler method name</td></tr>
<tr><td><code>controller_name</code></td><td><code>&amp;str</code></td><td>Controller struct name</td></tr>
<tr><td><code>headers</code></td><td><code>&amp;HeaderMap</code></td><td>Request headers</td></tr>
<tr><td><code>uri</code></td><td><code>&amp;Uri</code></td><td>Request URI</td></tr>
<tr><td><code>identity</code></td><td><code>Option&lt;&amp;I&gt;</code></td><td>Authenticated identity (if available)</td></tr>
</tbody>
</table>
</div>
<p>Convenience methods: <code>identity_sub()</code>, <code>identity_roles()</code>, <code>identity_email()</code>, <code>identity_claims()</code>, <code>path()</code>, <code>query_string()</code>.</p>
<h3 id="the-identity-trait"><a class="header" href="#the-identity-trait">The <code>Identity</code> trait</a></h3>
<p>Guards are generic over the <code>Identity</code> trait, decoupling them from the concrete <code>AuthenticatedUser</code> type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Identity: Send + Sync {
    fn sub(&amp;self) -&gt; &amp;str;
    fn roles(&amp;self) -&gt; &amp;[String];
    fn email(&amp;self) -&gt; Option&lt;&amp;str&gt; { None }
    fn claims(&amp;self) -&gt; Option&lt;&amp;serde_json::Value&gt; { None }
}
<span class="boring">}</span></code></pre>
<p><code>AuthenticatedUser</code> implements <code>Identity</code>. You can create custom identity types by implementing this trait.</p>
<h2 id="pre-auth-guards"><a class="header" href="#pre-auth-guards">Pre-auth guards</a></h2>
<p>For authorization that doesn’t need identity (e.g., IP allowlisting), use <code>PreAuthGuard</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::{PreAuthGuard, PreAuthGuardContext};

struct IpAllowlistGuard;

impl&lt;S: Send + Sync&gt; PreAuthGuard&lt;S&gt; for IpAllowlistGuard {
    fn check(
        &amp;self,
        state: &amp;S,
        ctx: &amp;PreAuthGuardContext&lt;'_&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            let ip = ctx.headers.get("x-forwarded-for")
                .and_then(|v| v.to_str().ok());
            match ip {
                Some("10.0.0.1") =&gt; Ok(()),
                _ =&gt; Err(AppError::Forbidden("IP not allowed".into()).into_response()),
            }
        }
    }
}

#[get("/")]
#[pre_guard(IpAllowlistGuard)]
async fn restricted(&amp;self) -&gt; &amp;'static str { "allowed" }
<span class="boring">}</span></code></pre>
<p>Pre-auth guards run <strong>before</strong> JWT extraction, avoiding wasted token validation.</p>
<h2 id="async-guards-with-database-access"><a class="header" href="#async-guards-with-database-access">Async guards with database access</a></h2>
<p>Guards can perform async operations like database lookups:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DatabaseGuard;

impl&lt;S: Send + Sync, I: Identity&gt; Guard&lt;S, I&gt; for DatabaseGuard
where
    sqlx::SqlitePool: FromRef&lt;S&gt;,
{
    fn check(
        &amp;self,
        state: &amp;S,
        ctx: &amp;GuardContext&lt;'_, I&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            let pool = sqlx::SqlitePool::from_ref(state);
            let allowed = sqlx::query_scalar::&lt;_, bool&gt;(
                "SELECT active FROM users WHERE sub = ?"
            )
            .bind(ctx.identity_sub().unwrap_or(""))
            .fetch_optional(&amp;pool)
            .await
            .map_err(|_| AppError::Internal("DB error".into()).into_response())?;

            match allowed {
                Some(true) =&gt; Ok(()),
                _ =&gt; Err(AppError::Forbidden("Account suspended".into()).into_response()),
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="guard-execution-order"><a class="header" href="#guard-execution-order">Guard execution order</a></h2>
<ol>
<li>Pre-auth guards (<code>#[pre_guard(...)]</code>) — run before JWT validation</li>
<li>Rate limit guards (<code>RateLimit::per_user(...)</code>) — run after JWT validation</li>
<li>Role guards (<code>#[roles("...")]</code>) — check identity roles</li>
<li>Custom guards (<code>#[guard(...)]</code>) — run after roles</li>
</ol>
<p>Guards short-circuit on first failure — later guards don’t run.</p>
<h2 id="combining-guards"><a class="header" href="#combining-guards">Combining guards</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
#[pre_guard(RateLimit::per_ip(10, 60))]      // Pre-auth: IP rate limit
#[guard(RateLimit::per_user(5, 60))]          // Post-auth: user rate limit
#[roles("editor")]                             // Role check
#[guard(TenantGuard)]                          // Custom check
async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Json&lt;Response&gt; {
    // Only reached if ALL guards pass
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h1>
<p>R2E provides token-bucket rate limiting with three key strategies: global, per-IP, and per-user.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>Enable the rate-limit feature:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["rate-limit"] }
</code></pre>
<p>Add <code>RateLimitRegistry</code> to your state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_rate_limit::RateLimitRegistry;

#[derive(Clone, BeanState)]
pub struct AppState {
    pub rate_limiter: RateLimitRegistry,
    // ...
}
<span class="boring">}</span></code></pre>
<p>Provide a default instance:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .provide(RateLimitRegistry::default())
    // ...
<span class="boring">}</span></code></pre>
<h2 id="rate-limit-strategies"><a class="header" href="#rate-limit-strategies">Rate limit strategies</a></h2>
<h3 id="global-rate-limit-pre-auth"><a class="header" href="#global-rate-limit-pre-auth">Global rate limit (pre-auth)</a></h3>
<p>Shared bucket across all requests. Runs before JWT validation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_rate_limit::RateLimit;

#[get("/")]
#[pre_guard(RateLimit::global(100, 60))]  // 100 requests per 60 seconds total
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;Item&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h3 id="per-ip-rate-limit-pre-auth"><a class="header" href="#per-ip-rate-limit-pre-auth">Per-IP rate limit (pre-auth)</a></h3>
<p>Separate bucket per client IP. Runs before JWT validation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
#[pre_guard(RateLimit::per_ip(10, 60))]  // 10 requests per 60 seconds per IP
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;Item&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<p>IP is extracted from the <code>X-Forwarded-For</code> header.</p>
<h3 id="per-user-rate-limit-post-auth"><a class="header" href="#per-user-rate-limit-post-auth">Per-user rate limit (post-auth)</a></h3>
<p>Separate bucket per authenticated user. Runs after JWT validation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
#[guard(RateLimit::per_user(5, 60))]  // 5 requests per 60 seconds per user
async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Json&lt;Response&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<p>User is identified by the <code>sub</code> claim from the JWT token.</p>
<h2 id="key-classification"><a class="header" href="#key-classification">Key classification</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Attribute</th><th>Runs when</th><th>Needs identity</th></tr>
</thead>
<tbody>
<tr><td><code>RateLimit::global(max, window)</code></td><td><code>#[pre_guard(...)]</code></td><td>Before JWT</td><td>No</td></tr>
<tr><td><code>RateLimit::per_ip(max, window)</code></td><td><code>#[pre_guard(...)]</code></td><td>Before JWT</td><td>No</td></tr>
<tr><td><code>RateLimit::per_user(max, window)</code></td><td><code>#[guard(...)]</code></td><td>After JWT</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="combining-rate-limits"><a class="header" href="#combining-rate-limits">Combining rate limits</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/upload")]
#[pre_guard(RateLimit::global(1000, 60))]     // 1000 total uploads/min
#[pre_guard(RateLimit::per_ip(50, 60))]       // 50 uploads/min per IP
#[guard(RateLimit::per_user(10, 60))]         // 10 uploads/min per user
async fn upload(&amp;self, body: Bytes) -&gt; Result&lt;(), AppError&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h2 id="response-on-rate-limit-exceeded"><a class="header" href="#response-on-rate-limit-exceeded">Response on rate limit exceeded</a></h2>
<p>When a rate limit is exceeded, R2E returns:</p>
<pre><code>HTTP/1.1 429 Too Many Requests
</code></pre>
<h2 id="custom-rate-limit-backend"><a class="header" href="#custom-rate-limit-backend">Custom rate limit backend</a></h2>
<p>The default backend is <code>InMemoryRateLimiter</code> (DashMap-based). For distributed rate limiting, implement the <code>RateLimitBackend</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_rate_limit::RateLimitBackend;

struct RedisRateLimiter { /* ... */ }

impl RateLimitBackend for RedisRateLimiter {
    async fn check_rate_limit(
        &amp;self,
        key: &amp;str,
        max_requests: u64,
        window_secs: u64,
    ) -&gt; bool {
        // Return true if allowed, false if exceeded
        todo!()
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="entities-and-repository"><a class="header" href="#entities-and-repository">Entities and Repository</a></h1>
<p>R2E provides data access abstractions: <code>Entity</code> for mapping Rust structs to SQL tables, and <code>Repository</code> for async CRUD operations.</p>
<h2 id="setup-3"><a class="header" href="#setup-3">Setup</a></h2>
<p>Enable the data feature:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["data"] }
sqlx = { version = "0.8", features = ["runtime-tokio", "sqlite"] }
</code></pre>
<h2 id="defining-entities"><a class="header" href="#defining-entities">Defining entities</a></h2>
<p>Implement the <code>Entity</code> trait to map a struct to a database table:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data::Entity;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: i64,
    pub name: String,
    pub email: String,
}

impl Entity for User {
    type Id = i64;

    fn table_name() -&gt; &amp;'static str {
        "users"
    }

    fn id_column() -&gt; &amp;'static str {
        "id"
    }

    fn columns() -&gt; &amp;'static [&amp;'static str] {
        &amp;["id", "name", "email"]
    }

    fn id(&amp;self) -&gt; &amp;i64 {
        &amp;self.id
    }
}
<span class="boring">}</span></code></pre>
<h3 id="entity-trait-methods"><a class="header" href="#entity-trait-methods">Entity trait methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>table_name()</code></td><td><code>&amp;'static str</code></td><td>SQL table name</td></tr>
<tr><td><code>id_column()</code></td><td><code>&amp;'static str</code></td><td>Primary key column name</td></tr>
<tr><td><code>columns()</code></td><td><code>&amp;'static [&amp;'static str]</code></td><td>All column names</td></tr>
<tr><td><code>id(&amp;self)</code></td><td><code>&amp;Id</code></td><td>Primary key value</td></tr>
</tbody>
</table>
</div>
<h2 id="using-sqlxrepository"><a class="header" href="#using-sqlxrepository">Using <code>SqlxRepository</code></a></h2>
<p><code>SqlxRepository</code> provides CRUD operations backed by SQLx:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data_sqlx::SqlxRepository;

let repo = SqlxRepository::&lt;User, _&gt;::new(pool.clone());

// Find by ID
let user: Option&lt;User&gt; = repo.find_by_id(&amp;1).await?;

// Find all
let users: Vec&lt;User&gt; = repo.find_all().await?;

// Create
let user = repo.create(&amp;new_user).await?;

// Update
repo.update(&amp;updated_user).await?;

// Delete
repo.delete(&amp;1).await?;
<span class="boring">}</span></code></pre>
<h2 id="in-controllers-1"><a class="header" href="#in-controllers-1">In controllers</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] pool: SqlitePool,
}

#[routes]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Result&lt;Json&lt;Vec&lt;User&gt;&gt;, AppError&gt; {
        let users = sqlx::query_as::&lt;_, User&gt;("SELECT id, name, email FROM users")
            .fetch_all(&amp;self.pool)
            .await
            .map_err(|e| AppError::Internal(e.to_string()))?;
        Ok(Json(users))
    }

    #[get("/{id}")]
    async fn get_by_id(&amp;self, Path(id): Path&lt;i64&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
        let user = sqlx::query_as::&lt;_, User&gt;(
            "SELECT id, name, email FROM users WHERE id = ?"
        )
        .bind(id)
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| AppError::Internal(e.to_string()))?
        .ok_or_else(|| AppError::NotFound("User not found".into()))?;

        Ok(Json(user))
    }
}
<span class="boring">}</span></code></pre>
<h2 id="haspool-trait"><a class="header" href="#haspool-trait">HasPool trait</a></h2>
<p>For controllers that use data-sqlx features, implement <code>HasPool</code> on your state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data_sqlx::HasPool;
use sqlx::{Pool, Sqlite};

impl HasPool&lt;Sqlite&gt; for AppState {
    fn pool(&amp;self) -&gt; &amp;Pool&lt;Sqlite&gt; {
        &amp;self.pool
    }
}
<span class="boring">}</span></code></pre>
<p>This is required for <code>#[managed]</code> transactions and <code>SqlxRepository</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="querybuilder"><a class="header" href="#querybuilder">QueryBuilder</a></h1>
<p>R2E’s <code>QueryBuilder</code> provides a fluent API for constructing SQL queries.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data::QueryBuilder;

let (sql, params) = QueryBuilder::new("users")
    .where_eq("email", "alice@example.com")
    .build_select("id, name, email");
// sql: "SELECT id, name, email FROM users WHERE email = ?"
// params: ["alice@example.com"]
<span class="boring">}</span></code></pre>
<h2 id="where-clauses"><a class="header" href="#where-clauses">Where clauses</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>SQL</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>where_eq(col, val)</code></td><td><code>col = ?</code></td><td><code>where_eq("status", "active")</code></td></tr>
<tr><td><code>where_like(col, val)</code></td><td><code>col LIKE ?</code></td><td><code>where_like("name", "%ali%")</code></td></tr>
<tr><td><code>where_gt(col, val)</code></td><td><code>col &gt; ?</code></td><td><code>where_gt("age", "18")</code></td></tr>
<tr><td><code>where_lt(col, val)</code></td><td><code>col &lt; ?</code></td><td><code>where_lt("price", "100")</code></td></tr>
<tr><td><code>where_gte(col, val)</code></td><td><code>col &gt;= ?</code></td><td><code>where_gte("score", "50")</code></td></tr>
<tr><td><code>where_lte(col, val)</code></td><td><code>col &lt;= ?</code></td><td><code>where_lte("count", "10")</code></td></tr>
<tr><td><code>where_in(col, vals)</code></td><td><code>col IN (?, ?)</code></td><td><code>where_in("id", &amp;["1", "2"])</code></td></tr>
<tr><td><code>where_null(col)</code></td><td><code>col IS NULL</code></td><td><code>where_null("deleted_at")</code></td></tr>
<tr><td><code>where_not_null(col)</code></td><td><code>col IS NOT NULL</code></td><td><code>where_not_null("email")</code></td></tr>
</tbody>
</table>
</div>
<h2 id="ordering-limits-offsets"><a class="header" href="#ordering-limits-offsets">Ordering, limits, offsets</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sql, params) = QueryBuilder::new("users")
    .where_like("name", "%ali%")
    .order_by("name", true)     // true = ASC, false = DESC
    .limit(10)
    .offset(20)
    .build_select("id, name, email");
// SELECT id, name, email FROM users WHERE name LIKE ? ORDER BY name ASC LIMIT 10 OFFSET 20
<span class="boring">}</span></code></pre>
<h2 id="count-queries"><a class="header" href="#count-queries">Count queries</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sql, params) = QueryBuilder::new("users")
    .where_eq("status", "active")
    .build_count();
// SELECT COUNT(*) FROM users WHERE status = ?
<span class="boring">}</span></code></pre>
<h2 id="combining-conditions"><a class="header" href="#combining-conditions">Combining conditions</a></h2>
<p>All where clauses are combined with AND:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sql, params) = QueryBuilder::new("users")
    .where_eq("status", "active")
    .where_like("name", "%ali%")
    .where_gt("age", "18")
    .order_by("created_at", false)
    .build_select("*");
// SELECT * FROM users WHERE status = ? AND name LIKE ? AND age &gt; ? ORDER BY created_at DESC
<span class="boring">}</span></code></pre>
<h2 id="using-with-sqlx"><a class="header" href="#using-with-sqlx">Using with SQLx</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (sql, params) = QueryBuilder::new("users")
    .where_eq("status", "active")
    .limit(10)
    .build_select("id, name, email");

let mut query = sqlx::query_as::&lt;_, User&gt;(&amp;sql);
for param in &amp;params {
    query = query.bind(param);
}
let users = query.fetch_all(&amp;self.pool).await?;
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<p>R2E provides <code>Pageable</code> for extracting pagination parameters from query strings and <code>Page&lt;T&gt;</code> for structured paginated responses.</p>
<h2 id="pageable-extractor"><a class="header" href="#pageable-extractor"><code>Pageable</code> extractor</a></h2>
<p><code>Pageable</code> is an Axum <code>Query</code> extractor with pagination parameters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data::{Pageable, Page};

#[get("/")]
async fn list(&amp;self, Query(pageable): Query&lt;Pageable&gt;) -&gt; Result&lt;Json&lt;Page&lt;User&gt;&gt;, AppError&gt; {
    // pageable.page  — page number (0-based, default: 0)
    // pageable.size  — items per page (default: 20)
    // pageable.sort  — sort field (optional)
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="query-string-format"><a class="header" href="#query-string-format">Query string format</a></h3>
<pre><code>GET /users?page=0&amp;size=20&amp;sort=name
GET /users?page=2&amp;size=10&amp;sort=created_at,desc
</code></pre>
<h2 id="paget-response"><a class="header" href="#paget-response"><code>Page&lt;T&gt;</code> response</a></h2>
<p><code>Page&lt;T&gt;</code> wraps paginated results with metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
pub struct Page&lt;T&gt; {
    pub content: Vec&lt;T&gt;,
    pub total_elements: i64,
    pub total_pages: i64,
    pub page: i64,
    pub size: i64,
}
<span class="boring">}</span></code></pre>
<h3 id="constructing-a-page"><a class="header" href="#constructing-a-page">Constructing a <code>Page</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Page::new(items, &amp;pageable, total_count)
<span class="boring">}</span></code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
async fn list(
    &amp;self,
    Query(pageable): Query&lt;Pageable&gt;,
) -&gt; Result&lt;Json&lt;Page&lt;User&gt;&gt;, AppError&gt; {
    let offset = pageable.page * pageable.size;

    // Get total count
    let total: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM users")
        .fetch_one(&amp;self.pool)
        .await
        .map_err(|e| AppError::Internal(e.to_string()))?;

    // Get page of results
    let users = sqlx::query_as::&lt;_, User&gt;(
        "SELECT id, name, email FROM users ORDER BY id LIMIT ? OFFSET ?"
    )
    .bind(pageable.size)
    .bind(offset)
    .fetch_all(&amp;self.pool)
    .await
    .map_err(|e| AppError::Internal(e.to_string()))?;

    Ok(Json(Page::new(users, &amp;pageable, total.0)))
}
<span class="boring">}</span></code></pre>
<h3 id="response-format"><a class="header" href="#response-format">Response format</a></h3>
<pre><code class="language-json">{
  "content": [
    {"id": 1, "name": "Alice", "email": "alice@example.com"},
    {"id": 2, "name": "Bob", "email": "bob@example.com"}
  ],
  "total_elements": 42,
  "total_pages": 3,
  "page": 0,
  "size": 20
}
</code></pre>
<h2 id="with-querybuilder"><a class="header" href="#with-querybuilder">With QueryBuilder</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data::QueryBuilder;

#[get("/")]
async fn list(
    &amp;self,
    Query(pageable): Query&lt;Pageable&gt;,
) -&gt; Result&lt;Json&lt;Page&lt;User&gt;&gt;, AppError&gt; {
    let mut qb = QueryBuilder::new("users");

    if let Some(ref sort) = pageable.sort {
        qb = qb.order_by(sort, true);
    }

    qb = qb.limit(pageable.size as usize)
            .offset((pageable.page * pageable.size) as usize);

    let (sql, params) = qb.build_select("id, name, email");
    let (count_sql, count_params) = QueryBuilder::new("users").build_count();

    // Execute both queries...
    // Return Page::new(users, &amp;pageable, total)
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transactions-and-managed-resources"><a class="header" href="#transactions-and-managed-resources">Transactions and Managed Resources</a></h1>
<p>R2E provides two approaches for transaction management: <code>#[managed]</code> for automatic lifecycle and <code>#[transactional]</code> for simple wrapping.</p>
<h2 id="managed--recommended"><a class="header" href="#managed--recommended"><code>#[managed]</code> — Recommended</a></h2>
<p>The <code>#[managed]</code> attribute provides automatic resource lifecycle management:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data_sqlx::Tx;
use sqlx::Sqlite;

#[post("/")]
async fn create(
    &amp;self,
    body: Json&lt;CreateUserRequest&gt;,
    #[managed] tx: &amp;mut Tx&lt;'_, Sqlite&gt;,
) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
    sqlx::query("INSERT INTO users (name, email) VALUES (?, ?)")
        .bind(&amp;body.name)
        .bind(&amp;body.email)
        .execute(tx.as_mut())
        .await?;

    Ok(Json(user))
}
<span class="boring">}</span></code></pre>
<h3 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h3>
<ol>
<li><strong>Acquire</strong>: <code>Tx::acquire(&amp;state)</code> — begins a transaction from the pool</li>
<li><strong>Handler runs</strong>: receives <code>&amp;mut Tx</code> — executes queries within the transaction</li>
<li><strong>Release</strong>: <code>Tx::release(self, success)</code> — commits on success, rolls back on failure
<ul>
<li><code>success = true</code> if handler returned <code>Ok</code> or a non-Result type</li>
<li><code>success = false</code> if handler returned <code>Err</code></li>
</ul>
</li>
</ol>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>Your state must implement <code>HasPool</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_data_sqlx::HasPool;

impl HasPool&lt;Sqlite&gt; for AppState {
    fn pool(&amp;self) -&gt; &amp;Pool&lt;Sqlite&gt; {
        &amp;self.pool
    }
}
<span class="boring">}</span></code></pre>
<h2 id="transactional--simple-wrapping"><a class="header" href="#transactional--simple-wrapping"><code>#[transactional]</code> — Simple wrapping</a></h2>
<p>For basic transaction wrapping without explicit <code>Tx</code> parameter:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
#[transactional]
async fn create(&amp;self, body: Json&lt;CreateUserRequest&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
    // self.pool is automatically wrapped in begin()/commit()
    sqlx::query("INSERT INTO users (name, email) VALUES (?, ?)")
        .bind(&amp;body.name)
        .bind(&amp;body.email)
        .execute(&amp;self.pool)
        .await?;

    Ok(Json(user))
}
<span class="boring">}</span></code></pre>
<p>Use <code>#[transactional(pool = "custom_pool")]</code> if your pool field has a different name.</p>
<blockquote>
<p><strong>Note:</strong> <code>#[managed]</code> and <code>#[transactional]</code> are mutually exclusive. Prefer <code>#[managed]</code> for new code — it’s more explicit and flexible.</p>
</blockquote>
<h2 id="custom-managed-resources"><a class="header" href="#custom-managed-resources">Custom managed resources</a></h2>
<p>Implement <code>ManagedResource&lt;S&gt;</code> for any type that needs acquire/release lifecycle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::ManagedResource;

pub struct Tx&lt;'a, DB: Database&gt;(pub Transaction&lt;'a, DB&gt;);

impl&lt;S, DB&gt; ManagedResource&lt;S&gt; for Tx&lt;'static, DB&gt;
where
    DB: Database,
    S: HasPool&lt;DB&gt; + Send + Sync,
{
    type Error = ManagedErr&lt;MyAppError&gt;;

    async fn acquire(state: &amp;S) -&gt; Result&lt;Self, Self::Error&gt; {
        let tx = state.pool().begin().await
            .map_err(|e| ManagedErr(MyAppError::Database(e.to_string())))?;
        Ok(Tx(tx))
    }

    async fn release(self, success: bool) -&gt; Result&lt;(), Self::Error&gt; {
        if success {
            self.0.commit().await
                .map_err(|e| ManagedErr(MyAppError::Database(e.to_string())))?;
        }
        // On failure: transaction dropped → automatic rollback
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="error-wrappers"><a class="header" href="#error-wrappers">Error wrappers</a></h3>
<p><code>ManagedResource::Error</code> must implement <code>Into&lt;Response&gt;</code>. Use <code>ManagedErr&lt;E&gt;</code> to wrap your custom error type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Your error type
impl IntoResponse for MyAppError { /* ... */ }

// ManagedResource uses the wrapper
type Error = ManagedErr&lt;MyAppError&gt;;
<span class="boring">}</span></code></pre>
<p>The chain is: <code>MyAppError</code> → <code>ManagedErr&lt;MyAppError&gt;</code> → <code>Response</code>.</p>
<h2 id="other-managed-resource-ideas"><a class="header" href="#other-managed-resource-ideas">Other managed resource ideas</a></h2>
<p>The pattern isn’t limited to transactions:</p>
<ul>
<li><strong>Audit context</strong> — acquire logs “action started”, release logs “action completed”</li>
<li><strong>Scoped cache</strong> — acquire creates a request-scoped cache, release flushes it</li>
<li><strong>Connection checkout</strong> — acquire checks out a connection, release returns it</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="event-bus"><a class="header" href="#event-bus">Event Bus</a></h1>
<p>R2E provides an in-process typed pub/sub event bus for decoupling components.</p>
<h2 id="setup-4"><a class="header" href="#setup-4">Setup</a></h2>
<p>Enable the events feature:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["events"] }
</code></pre>
<h2 id="defining-events"><a class="header" href="#defining-events">Defining events</a></h2>
<p>Events are plain Rust types. No trait implementation needed — just <code>Send + Sync + 'static</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct UserCreatedEvent {
    pub user_id: u64,
    pub name: String,
    pub email: String,
}

#[derive(Debug, Clone)]
pub struct OrderPlacedEvent {
    pub order_id: u64,
    pub total: f64,
}
<span class="boring">}</span></code></pre>
<h2 id="creating-the-eventbus"><a class="header" href="#creating-the-eventbus">Creating the EventBus</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_bus = EventBus::new();
<span class="boring">}</span></code></pre>
<p>Add it to your state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, BeanState)]
pub struct AppState {
    pub event_bus: EventBus,
    // ...
}
<span class="boring">}</span></code></pre>
<h2 id="subscribing-to-events"><a class="header" href="#subscribing-to-events">Subscribing to events</a></h2>
<p>Subscribers receive events wrapped in <code>Arc&lt;E&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_bus.subscribe(|event: Arc&lt;UserCreatedEvent&gt;| async move {
    tracing::info!(user_id = event.user_id, "User created: {}", event.name);
}).await;
<span class="boring">}</span></code></pre>
<p>Multiple subscribers can listen to the same event type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Send welcome email
event_bus.subscribe(|event: Arc&lt;UserCreatedEvent&gt;| async move {
    send_welcome_email(&amp;event.email).await;
}).await;

// Update analytics
event_bus.subscribe(|event: Arc&lt;UserCreatedEvent&gt;| async move {
    analytics.track_signup(event.user_id).await;
}).await;
<span class="boring">}</span></code></pre>
<h2 id="emitting-events"><a class="header" href="#emitting-events">Emitting events</a></h2>
<h3 id="fire-and-forget"><a class="header" href="#fire-and-forget">Fire-and-forget</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.event_bus.emit(UserCreatedEvent {
    user_id: user.id,
    name: user.name.clone(),
    email: user.email.clone(),
}).await;
<span class="boring">}</span></code></pre>
<p>Handlers are spawned as concurrent tasks — <code>emit()</code> returns immediately.</p>
<h3 id="wait-for-completion"><a class="header" href="#wait-for-completion">Wait for completion</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.event_bus.emit_and_wait(UserCreatedEvent {
    user_id: user.id,
    name: user.name.clone(),
    email: user.email.clone(),
}).await;
<span class="boring">}</span></code></pre>
<p><code>emit_and_wait()</code> blocks until all handlers complete. Use this when downstream processing must finish before responding.</p>
<h2 id="type-safety"><a class="header" href="#type-safety">Type safety</a></h2>
<p>Events are dispatched by <code>TypeId</code>. Each event type has its own set of subscribers. There’s no downcasting or string-based routing — everything is type-safe at compile time.</p>
<h2 id="in-services"><a class="header" href="#in-services">In services</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct UserService {
    event_bus: EventBus,
    // ...
}

#[bean]
impl UserService {
    pub fn new(event_bus: EventBus) -&gt; Self {
        Self { event_bus }
    }

    pub async fn create(&amp;self, name: String, email: String) -&gt; User {
        let user = /* create user */;

        // Notify interested parties
        self.event_bus.emit(UserCreatedEvent {
            user_id: user.id,
            name: user.name.clone(),
            email: user.email.clone(),
        }).await;

        user
    }
}
<span class="boring">}</span></code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next steps</a></h2>
<ul>
<li><a href="#declarative-consumers">Declarative Consumers</a> — use <code>#[consumer]</code> for cleaner event handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="declarative-consumers"><a class="header" href="#declarative-consumers">Declarative Consumers</a></h1>
<p>Instead of manually calling <code>event_bus.subscribe()</code>, use <code>#[consumer]</code> for declarative event handling within a controller.</p>
<h2 id="defining-a-consumer"><a class="header" href="#defining-a-consumer">Defining a consumer</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(state = AppState)]
pub struct UserEventConsumer {
    #[inject] event_bus: EventBus,
}

#[routes]
impl UserEventConsumer {
    #[consumer(bus = "event_bus")]
    async fn on_user_created(&amp;self, event: Arc&lt;UserCreatedEvent&gt;) {
        tracing::info!(
            user_id = event.user_id,
            "User created: {} ({})",
            event.name,
            event.email,
        );
    }

    #[consumer(bus = "event_bus")]
    async fn on_order_placed(&amp;self, event: Arc&lt;OrderPlacedEvent&gt;) {
        tracing::info!(order_id = event.order_id, "Order placed: ${}", event.total);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<ol>
<li><code>#[consumer(bus = "event_bus")]</code> tells R2E which <code>EventBus</code> field to subscribe to</li>
<li>The event type is inferred from the parameter type (<code>Arc&lt;UserCreatedEvent&gt;</code>)</li>
<li><code>register_controller::&lt;UserEventConsumer&gt;()</code> auto-discovers and registers all consumer methods</li>
<li>At runtime, the controller is constructed from state via <code>StatefulConstruct</code> and the closure subscribes to events</li>
</ol>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>The controller must have an <code>EventBus</code> field (named in the <code>bus = "..."</code> attribute)</li>
<li>The controller must <strong>not</strong> have struct-level <code>#[inject(identity)]</code> fields (consumers need <code>StatefulConstruct</code>)</li>
<li>The consumer method must take <code>&amp;self</code> and <code>Arc&lt;EventType&gt;</code></li>
<li>Consumer controllers don’t need a <code>path</code> in <code>#[controller]</code></li>
</ul>
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>Register consumer controllers like any other controller:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .provide(event_bus)
    .build_state::&lt;AppState, _&gt;()
    .await
    .register_controller::&lt;UserEventConsumer&gt;()
    // ...
<span class="boring">}</span></code></pre>
<h2 id="mixed-controllers"><a class="header" href="#mixed-controllers">Mixed controllers</a></h2>
<p>A controller can have both HTTP routes and consumers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/notifications", state = AppState)]
pub struct NotificationController {
    #[inject] event_bus: EventBus,
    #[inject] notification_service: NotificationService,
}

#[routes]
impl NotificationController {
    // HTTP route
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;Notification&gt;&gt; {
        Json(self.notification_service.list().await)
    }

    // Event consumer
    #[consumer(bus = "event_bus")]
    async fn on_user_created(&amp;self, event: Arc&lt;UserCreatedEvent&gt;) {
        self.notification_service.send(
            &amp;event.email,
            "Welcome!",
        ).await;
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h1>
<p>R2E provides declarative background task scheduling with interval, cron, and delayed execution.</p>
<h2 id="setup-5"><a class="header" href="#setup-5">Setup</a></h2>
<p>Enable the scheduler feature and install the <code>Scheduler</code> plugin:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["scheduler"] }
</code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_scheduler::Scheduler;

AppBuilder::new()
    .plugin(Scheduler)                  // MUST be before build_state()
    .build_state::&lt;AppState, _&gt;()
    .await
    .register_controller::&lt;ScheduledJobs&gt;()
    .serve("0.0.0.0:3000")
    .await
    .unwrap();
<span class="boring">}</span></code></pre>
<p>The <code>Scheduler</code> plugin must be installed <strong>before</strong> <code>build_state()</code> because it provides a <code>CancellationToken</code> to the bean graph.</p>
<h2 id="declaring-scheduled-tasks"><a class="header" href="#declaring-scheduled-tasks">Declaring scheduled tasks</a></h2>
<p>Use <code>#[scheduled]</code> on controller methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(state = AppState)]
pub struct ScheduledJobs {
    #[inject] user_service: UserService,
}

#[routes]
impl ScheduledJobs {
    // Run every 30 seconds
    #[scheduled(every = 30)]
    async fn count_users(&amp;self) {
        let count = self.user_service.count().await;
        tracing::info!(count, "Scheduled user count");
    }

    // Run on a cron schedule (every hour)
    #[scheduled(cron = "0 0 * * * *")]
    async fn hourly_cleanup(&amp;self) {
        tracing::info!("Running hourly cleanup");
    }

    // Run every 60 seconds, first execution after 10 second delay
    #[scheduled(every = 60, delay = 10)]
    async fn delayed_task(&amp;self) {
        tracing::info!("Delayed task executed");
    }
}
<span class="boring">}</span></code></pre>
<h2 id="schedule-types"><a class="header" href="#schedule-types">Schedule types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>every = N</code></td><td>Run every N seconds</td><td><code>#[scheduled(every = 30)]</code></td></tr>
<tr><td><code>every = N, delay = D</code></td><td>Every N seconds, first run after D seconds</td><td><code>#[scheduled(every = 60, delay = 10)]</code></td></tr>
<tr><td><code>cron = "expr"</code></td><td>Cron expression (6 fields)</td><td><code>#[scheduled(cron = "0 */5 * * * *")]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="cron-expression-format"><a class="header" href="#cron-expression-format">Cron expression format</a></h3>
<p>Six fields: <code>second minute hour day_of_month month day_of_week</code></p>
<pre><code>0 */5 * * * *      — every 5 minutes
0 0 * * * *        — every hour
0 0 0 * * *        — every day at midnight
0 30 9 * * MON-FRI — weekdays at 9:30 AM
</code></pre>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li>Scheduled controller must <strong>not</strong> have struct-level <code>#[inject(identity)]</code> fields (needs <code>StatefulConstruct</code>)</li>
<li>The <code>Scheduler</code> plugin must be installed before <code>build_state()</code></li>
<li>Scheduled methods take <code>&amp;self</code> only (no additional parameters)</li>
</ul>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works</a></h2>
<ol>
<li><code>Scheduler</code> plugin creates a <code>CancellationToken</code> and defers setup</li>
<li><code>build_state()</code> provides the token to the bean graph</li>
<li><code>register_controller::&lt;ScheduledJobs&gt;()</code> collects scheduled task definitions</li>
<li><code>serve()</code> starts all scheduled tasks as Tokio tasks</li>
<li>On shutdown (Ctrl-C / SIGTERM), the <code>CancellationToken</code> is cancelled, stopping all tasks</li>
</ol>
<h2 id="error-handling-in-scheduled-tasks"><a class="header" href="#error-handling-in-scheduled-tasks">Error handling in scheduled tasks</a></h2>
<p>Scheduled methods can return <code>Result</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[scheduled(every = 60)]
async fn cleanup(&amp;self) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    self.service.cleanup().await?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<p>Errors are logged but don’t stop the scheduler — the task runs again at the next interval.</p>
<h2 id="mixed-controllers-1"><a class="header" href="#mixed-controllers-1">Mixed controllers</a></h2>
<p>A controller can have both HTTP routes and scheduled tasks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/stats", state = AppState)]
pub struct StatsController {
    #[inject] stats_service: StatsService,
}

#[routes]
impl StatsController {
    #[get("/")]
    async fn get_stats(&amp;self) -&gt; Json&lt;Stats&gt; {
        Json(self.stats_service.current().await)
    }

    #[scheduled(every = 300)]
    async fn refresh_stats(&amp;self) {
        self.stats_service.refresh().await;
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interceptors"><a class="header" href="#interceptors">Interceptors</a></h1>
<p>Interceptors implement cross-cutting concerns (logging, timing, caching) via a generic <code>Interceptor&lt;R&gt;</code> trait with an <code>around</code> pattern. All calls are monomorphized — zero runtime overhead.</p>
<h2 id="built-in-interceptors"><a class="header" href="#built-in-interceptors">Built-in interceptors</a></h2>
<p>R2E provides four built-in interceptors in <code>r2e-utils</code>:</p>
<h3 id="logged--request-logging"><a class="header" href="#logged--request-logging"><code>Logged</code> — Request logging</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[routes]
#[intercept(Logged::info())]  // Log all methods at INFO level
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre>
<p>Available levels: <code>Logged::trace()</code>, <code>Logged::debug()</code>, <code>Logged::info()</code>, <code>Logged::warn()</code>, <code>Logged::error()</code>.</p>
<h3 id="timed--execution-timing"><a class="header" href="#timed--execution-timing"><code>Timed</code> — Execution timing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
#[intercept(Timed::new())]              // Always log execution time
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }

#[get("/slow")]
#[intercept(Timed::threshold(50))]      // Only log if &gt;50ms
async fn slow_query(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h3 id="cache--response-caching"><a class="header" href="#cache--response-caching"><code>Cache</code> — Response caching</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
#[intercept(Cache::ttl(30))]                     // Cache for 30 seconds
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }

#[get("/")]
#[intercept(Cache::ttl(30).group("users"))]      // Named cache group
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h3 id="cacheinvalidate--clear-cache-groups"><a class="header" href="#cacheinvalidate--clear-cache-groups"><code>CacheInvalidate</code> — Clear cache groups</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
#[intercept(CacheInvalidate::group("users"))]    // Clear "users" cache after execution
async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Json&lt;User&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h2 id="controller-level-interceptors"><a class="header" href="#controller-level-interceptors">Controller-level interceptors</a></h2>
<p>Apply to all methods in a controller:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[routes]
#[intercept(Logged::info())]
impl UserController {
    // All methods get logged
}
<span class="boring">}</span></code></pre>
<h2 id="method-level-interceptors"><a class="header" href="#method-level-interceptors">Method-level interceptors</a></h2>
<p>Apply to individual methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[routes]
impl UserController {
    #[get("/")]
    #[intercept(Timed::threshold(100))]
    #[intercept(Cache::ttl(60).group("users"))]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }

    #[post("/")]
    #[intercept(CacheInvalidate::group("users"))]
    async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Json&lt;User&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre>
<h2 id="execution-order"><a class="header" href="#execution-order">Execution order</a></h2>
<p>When multiple interceptors are applied, they wrap in this order (outermost to innermost):</p>
<ol>
<li><code>Logged</code> (controller-level, then method-level)</li>
<li><code>Timed</code></li>
<li>User-defined interceptors (<code>#[intercept(...)]</code>)</li>
<li><code>Cache</code></li>
<li>Method body</li>
<li><code>CacheInvalidate</code> (after body)</li>
</ol>
<h2 id="writing-custom-interceptors"><a class="header" href="#writing-custom-interceptors">Writing custom interceptors</a></h2>
<p>Implement the <code>Interceptor&lt;R&gt;</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::interceptors::{Interceptor, InterceptorContext};
use std::future::Future;

pub struct AuditLog;

impl&lt;R: Send&gt; Interceptor&lt;R&gt; for AuditLog {
    fn around&lt;F, Fut&gt;(&amp;self, ctx: InterceptorContext, next: F) -&gt; impl Future&lt;Output = R&gt; + Send
    where
        F: FnOnce() -&gt; Fut + Send,
        Fut: Future&lt;Output = R&gt; + Send,
    {
        async move {
            tracing::info!(
                controller = ctx.controller_name,
                method = ctx.method_name,
                "audit: entering"
            );
            let result = next().await;
            tracing::info!(
                controller = ctx.controller_name,
                method = ctx.method_name,
                "audit: completed"
            );
            result
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Apply it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/")]
#[intercept(AuditLog)]
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<p>The type must be constructable as a bare path expression (unit struct or constant).</p>
<h3 id="interceptorcontext"><a class="header" href="#interceptorcontext"><code>InterceptorContext</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>controller_name</code></td><td><code>&amp;'static str</code></td><td>Controller struct name</td></tr>
<tr><td><code>method_name</code></td><td><code>&amp;'static str</code></td><td>Handler method name</td></tr>
</tbody>
</table>
</div>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Interceptors are monomorphized (no <code>dyn</code>, no vtable). The overhead is ~100 ns per interceptor — effectively free in any real application.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-guards"><a class="header" href="#custom-guards">Custom Guards</a></h1>
<p>Guards run authorization checks before the handler body. R2E supports two guard types: post-auth (<code>Guard</code>) and pre-auth (<code>PreAuthGuard</code>).</p>
<h2 id="post-auth-guards"><a class="header" href="#post-auth-guards">Post-auth guards</a></h2>
<p>Post-auth guards run after JWT validation and have access to the identity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::{Guard, GuardContext, Identity, AppError};
use axum::response::{IntoResponse, Response};

struct TenantGuard;

impl&lt;S: Send + Sync, I: Identity&gt; Guard&lt;S, I&gt; for TenantGuard {
    fn check(
        &amp;self,
        _state: &amp;S,
        ctx: &amp;GuardContext&lt;'_, I&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            let tenant_id = ctx.uri().path().split('/').nth(2);
            let user_tenant = ctx.identity_claims()
                .and_then(|c| c["tenant_id"].as_str());

            match (tenant_id, user_tenant) {
                (Some(path_tenant), Some(jwt_tenant)) if path_tenant == jwt_tenant =&gt; Ok(()),
                _ =&gt; Err(AppError::Forbidden("Tenant mismatch".into()).into_response()),
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Apply with <code>#[guard(...)]</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[get("/{tenant_id}/data")]
#[guard(TenantGuard)]
async fn get_tenant_data(&amp;self) -&gt; Json&lt;Data&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h2 id="pre-auth-guards-1"><a class="header" href="#pre-auth-guards-1">Pre-auth guards</a></h2>
<p>Pre-auth guards run before JWT validation — useful for checks that don’t need identity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::{PreAuthGuard, PreAuthGuardContext};

struct MaintenanceGuard;

impl&lt;S: Send + Sync&gt; PreAuthGuard&lt;S&gt; for MaintenanceGuard {
    fn check(
        &amp;self,
        _state: &amp;S,
        _ctx: &amp;PreAuthGuardContext&lt;'_&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            if is_maintenance_mode() {
                Err(AppError::Custom {
                    status: StatusCode::SERVICE_UNAVAILABLE,
                    body: serde_json::json!({"error": "Under maintenance"}),
                }.into_response())
            } else {
                Ok(())
            }
        }
    }
}

#[get("/")]
#[pre_guard(MaintenanceGuard)]
async fn list(&amp;self) -&gt; Json&lt;Vec&lt;Item&gt;&gt; { /* ... */ }
<span class="boring">}</span></code></pre>
<h2 id="guards-with-state-access"><a class="header" href="#guards-with-state-access">Guards with state access</a></h2>
<p>Guards can access the application state for database lookups or configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ActiveUserGuard;

impl&lt;S: Send + Sync, I: Identity&gt; Guard&lt;S, I&gt; for ActiveUserGuard
where
    SqlitePool: FromRef&lt;S&gt;,
{
    fn check(
        &amp;self,
        state: &amp;S,
        ctx: &amp;GuardContext&lt;'_, I&gt;,
    ) -&gt; impl Future&lt;Output = Result&lt;(), Response&gt;&gt; + Send {
        async move {
            let pool = SqlitePool::from_ref(state);
            let sub = ctx.identity_sub().unwrap_or("");

            let active = sqlx::query_scalar::&lt;_, bool&gt;(
                "SELECT active FROM users WHERE sub = ?"
            )
            .bind(sub)
            .fetch_optional(&amp;pool)
            .await
            .map_err(|_| AppError::Internal("DB error".into()).into_response())?;

            match active {
                Some(true) =&gt; Ok(()),
                _ =&gt; Err(AppError::Forbidden("Account suspended".into()).into_response()),
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="guard-context"><a class="header" href="#guard-context">Guard context</a></h2>
<h3 id="post-auth-guardcontexti"><a class="header" href="#post-auth-guardcontexti">Post-auth <code>GuardContext&lt;I&gt;</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field/Method</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>method_name</code></td><td><code>&amp;str</code></td><td>Handler method name</td></tr>
<tr><td><code>controller_name</code></td><td><code>&amp;str</code></td><td>Controller struct name</td></tr>
<tr><td><code>headers</code></td><td><code>&amp;HeaderMap</code></td><td>Request headers</td></tr>
<tr><td><code>uri</code></td><td><code>&amp;Uri</code></td><td>Request URI</td></tr>
<tr><td><code>identity</code></td><td><code>Option&lt;&amp;I&gt;</code></td><td>Authenticated identity</td></tr>
<tr><td><code>identity_sub()</code></td><td><code>Option&lt;&amp;str&gt;</code></td><td>Subject from identity</td></tr>
<tr><td><code>identity_roles()</code></td><td><code>Option&lt;&amp;[String]&gt;</code></td><td>Roles from identity</td></tr>
<tr><td><code>identity_email()</code></td><td><code>Option&lt;&amp;str&gt;</code></td><td>Email from identity</td></tr>
<tr><td><code>identity_claims()</code></td><td><code>Option&lt;&amp;Value&gt;</code></td><td>Raw JWT claims</td></tr>
<tr><td><code>path()</code></td><td><code>&amp;str</code></td><td>Request path</td></tr>
<tr><td><code>query_string()</code></td><td><code>Option&lt;&amp;str&gt;</code></td><td>Query string</td></tr>
</tbody>
</table>
</div>
<h3 id="pre-auth-preauthguardcontext"><a class="header" href="#pre-auth-preauthguardcontext">Pre-auth <code>PreAuthGuardContext</code></a></h3>
<p>Same as above but without <code>identity</code> (and no identity-related methods).</p>
<h2 id="combining-guards-1"><a class="header" href="#combining-guards-1">Combining guards</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
#[pre_guard(MaintenanceGuard)]                // pre-auth checks
#[pre_guard(RateLimit::per_ip(10, 60))]       // IP rate limit
#[roles("editor")]                             // role check
#[guard(TenantGuard)]                          // custom post-auth
#[guard(ActiveUserGuard)]                      // another post-auth
async fn create(&amp;self, body: Json&lt;Request&gt;) -&gt; Json&lt;Response&gt; {
    // Reached only if ALL guards pass
}
<span class="boring">}</span></code></pre>
<p>Guards execute in order and short-circuit on first failure.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-plugins"><a class="header" href="#custom-plugins">Custom Plugins</a></h1>
<p>Plugins encapsulate reusable middleware, routes, and services. R2E supports two plugin types: post-state (<code>Plugin</code>) and pre-state (<code>PreStatePlugin</code>).</p>
<h2 id="post-state-plugins-1"><a class="header" href="#post-state-plugins-1">Post-state plugins</a></h2>
<p>Install after <code>build_state()</code> with <code>.with(plugin)</code>. They receive and transform the <code>AppBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::Plugin;
use r2e::AppBuilder;

pub struct RequestLogger;

impl Plugin for RequestLogger {
    fn install&lt;T: Clone + Send + Sync + 'static&gt;(self, app: AppBuilder&lt;T&gt;) -&gt; AppBuilder&lt;T&gt; {
        app.with_layer_fn(|router| {
            router.layer(axum::middleware::from_fn(|req, next| async move {
                tracing::info!("Request: {} {}", req.method(), req.uri());
                next.run(req).await
            }))
        })
    }
}
<span class="boring">}</span></code></pre>
<p>Usage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(RequestLogger)
    // ...
<span class="boring">}</span></code></pre>
<h3 id="ordering-hint"><a class="header" href="#ordering-hint">Ordering hint</a></h3>
<p>Override <code>should_be_last()</code> for plugins that must be the outermost layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for NormalizePathPlugin {
    fn install&lt;T: Clone + Send + Sync + 'static&gt;(self, app: AppBuilder&lt;T&gt;) -&gt; AppBuilder&lt;T&gt; {
        app.with_layer_fn(|router| router.layer(NormalizePathLayer::trim_trailing_slash()))
    }

    fn should_be_last() -&gt; bool
    where
        Self: Sized,
    {
        true // R2E warns if plugins are added after this one
    }
}
<span class="boring">}</span></code></pre>
<h2 id="pre-state-plugins-2"><a class="header" href="#pre-state-plugins-2">Pre-state plugins</a></h2>
<p>Install before <code>build_state()</code> with <code>.plugin(plugin)</code>. They provide beans to the DI graph:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::{PreStatePlugin, AppBuilder};
use r2e::builder::NoState;
use r2e::type_list::TCons;

pub struct MyPlugin {
    config: MyPluginConfig,
}

impl PreStatePlugin for MyPlugin {
    type Provided = MyPluginConfig;

    fn install&lt;P&gt;(self, app: AppBuilder&lt;NoState, P&gt;) -&gt; AppBuilder&lt;NoState, TCons&lt;Self::Provided, P&gt;&gt; {
        app.provide(self.config)
    }
}
<span class="boring">}</span></code></pre>
<p>Usage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .plugin(MyPlugin { config: MyPluginConfig::default() })
    .build_state::&lt;AppState, _&gt;()
    .await
    // ...
<span class="boring">}</span></code></pre>
<h2 id="deferred-actions-1"><a class="header" href="#deferred-actions-1">Deferred actions</a></h2>
<p>For plugins that need to set up infrastructure after state is built but during serve:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::{PreStatePlugin, AppBuilder};
use r2e::plugin::{DeferredAction, DeferredContext};
use r2e::builder::NoState;
use r2e::type_list::TCons;
use tokio_util::sync::CancellationToken;

pub struct MyPlugin;

impl PreStatePlugin for MyPlugin {
    type Provided = CancellationToken;

    fn install&lt;P&gt;(self, app: AppBuilder&lt;NoState, P&gt;) -&gt; AppBuilder&lt;NoState, TCons&lt;Self::Provided, P&gt;&gt; {
        let token = CancellationToken::new();

        app.provide(token.clone()).add_deferred(DeferredAction::new("my-plugin", move |ctx: &amp;mut DeferredContext| {
            // Add a Tower layer
            ctx.add_layer(Box::new(|router| router.layer(axum::Extension("my-plugin-data"))));

            // Store data for later access
            ctx.store_data(MyPluginHandle::new());

            // Hook into server lifecycle
            let t = token.clone();
            ctx.on_serve(move |_tasks, _cancel_token| {
                tracing::info!("Plugin started");
            });

            ctx.on_shutdown(move || {
                t.cancel();
                tracing::info!("Plugin shutting down");
            });
        }))
    }
}
<span class="boring">}</span></code></pre>
<h3 id="deferredcontext-methods"><a class="header" href="#deferredcontext-methods">DeferredContext methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Signature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>add_layer</code></td><td><code>(&amp;mut self, Box&lt;dyn FnOnce(Router) -&gt; Router + Send&gt;)</code></td><td>Add a Tower layer to the router</td></tr>
<tr><td><code>store_data</code></td><td><code>&lt;D: Any + Send + Sync&gt;(&amp;mut self, D)</code></td><td>Store a value keyed by type for later retrieval</td></tr>
<tr><td><code>on_serve</code></td><td><code>(&amp;mut self, FnOnce(Vec&lt;Box&lt;dyn Any + Send&gt;&gt;, CancellationToken))</code></td><td>Run when the server starts listening</td></tr>
<tr><td><code>on_shutdown</code></td><td><code>(&amp;mut self, FnOnce())</code></td><td>Run during graceful shutdown</td></tr>
</tbody>
</table>
</div>
<h2 id="step-by-step-request-id-plugin"><a class="header" href="#step-by-step-request-id-plugin">Step-by-step: Request ID plugin</a></h2>
<p>A post-state plugin that adds a unique <code>X-Request-Id</code> header to every response.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::{Plugin, AppBuilder};
use axum::http::{Request, HeaderValue};
use axum::middleware::{self, Next};
use axum::response::Response;
use uuid::Uuid;

pub struct RequestId;

impl Plugin for RequestId {
    fn install&lt;T: Clone + Send + Sync + 'static&gt;(self, app: AppBuilder&lt;T&gt;) -&gt; AppBuilder&lt;T&gt; {
        app.with_layer_fn(|router| {
            router.layer(middleware::from_fn(request_id_middleware))
        })
    }
}

async fn request_id_middleware(
    request: Request&lt;axum::body::Body&gt;,
    next: Next,
) -&gt; Response {
    let request_id = Uuid::new_v4().to_string();
    let mut response = next.run(request).await;
    response.headers_mut().insert(
        "X-Request-Id",
        HeaderValue::from_str(&amp;request_id).unwrap(),
    );
    response
}
<span class="boring">}</span></code></pre>
<p>Usage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(RequestId)
    .serve("0.0.0.0:3000")
    .await;
<span class="boring">}</span></code></pre>
<h2 id="step-by-step-background-health-checker"><a class="header" href="#step-by-step-background-health-checker">Step-by-step: Background health checker</a></h2>
<p>A pre-state plugin that spawns a periodic health check task and cancels it on shutdown.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::{PreStatePlugin, AppBuilder};
use r2e::plugin::{DeferredAction, DeferredContext};
use r2e::builder::NoState;
use r2e::type_list::TCons;
use tokio_util::sync::CancellationToken;
use std::time::Duration;

pub struct HealthChecker {
    pub interval: Duration,
    pub url: String,
}

impl PreStatePlugin for HealthChecker {
    type Provided = CancellationToken;

    fn install&lt;P&gt;(self, app: AppBuilder&lt;NoState, P&gt;) -&gt; AppBuilder&lt;NoState, TCons&lt;Self::Provided, P&gt;&gt; {
        let token = CancellationToken::new();
        let interval = self.interval;
        let url = self.url;

        app.provide(token.clone()).add_deferred(DeferredAction::new("health-checker", move |ctx: &amp;mut DeferredContext| {
            let t = token.clone();

            // Start the checker when the server begins serving
            ctx.on_serve(move |_tasks, _cancel_token| {
                let t = t.clone();
                tokio::spawn(async move {
                    loop {
                        tokio::select! {
                            _ = tokio::time::sleep(interval) =&gt; {
                                match reqwest::get(&amp;url).await {
                                    Ok(resp) =&gt; tracing::info!("Health check: {}", resp.status()),
                                    Err(e) =&gt; tracing::warn!("Health check failed: {}", e),
                                }
                            }
                            _ = t.cancelled() =&gt; {
                                tracing::info!("Health checker stopped");
                                break;
                            }
                        }
                    }
                });
            });

            // Cancel the checker on shutdown
            ctx.on_shutdown(move || {
                token.cancel();
            });
        }))
    }
}
<span class="boring">}</span></code></pre>
<p>Usage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;

AppBuilder::new()
    .plugin(HealthChecker {
        interval: Duration::from_secs(30),
        url: "https://api.example.com/health".into(),
    })
    .build_state::&lt;AppState, _&gt;()
    .await
    .serve("0.0.0.0:3000")
    .await;
<span class="boring">}</span></code></pre>
<h2 id="available-appbuilder-methods-for-plugin-authors"><a class="header" href="#available-appbuilder-methods-for-plugin-authors">Available AppBuilder methods for plugin authors</a></h2>
<p>Post-state plugins (<code>Plugin::install</code>) receive <code>AppBuilder&lt;T&gt;</code> and can call:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>with_layer(layer)</code></td><td>Add a Tower layer (strict type bounds)</td></tr>
<tr><td><code>with_layer_fn(|router| ...)</code></td><td>Apply a custom router transformation (escape hatch)</td></tr>
<tr><td><code>with_service_builder(|router| ...)</code></td><td>Alias for <code>with_layer_fn</code></td></tr>
<tr><td><code>register_routes(router)</code></td><td>Merge a raw <code>axum::Router&lt;T&gt;</code> into the app</td></tr>
<tr><td><code>merge_router(router)</code></td><td>Alias for <code>register_routes</code></td></tr>
<tr><td><code>on_start(|state| async { Ok(()) })</code></td><td>Register a startup hook (runs before listening)</td></tr>
<tr><td><code>on_stop(|| async { })</code></td><td>Register a shutdown hook (runs after signal)</td></tr>
</tbody>
</table>
</div>
<h2 id="example-metrics-plugin"><a class="header" href="#example-metrics-plugin">Example: Metrics plugin</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::{Plugin, AppBuilder};
use axum::routing::get;
use axum::Router;

pub struct MetricsPlugin {
    endpoint: String,
}

impl MetricsPlugin {
    pub fn new(endpoint: &amp;str) -&gt; Self {
        Self { endpoint: endpoint.to_string() }
    }
}

impl Plugin for MetricsPlugin {
    fn install&lt;T: Clone + Send + Sync + 'static&gt;(self, app: AppBuilder&lt;T&gt;) -&gt; AppBuilder&lt;T&gt; {
        let metrics_router = Router::new()
            .route(&amp;self.endpoint, get(|| async { "metrics data" }));
        app.register_routes(metrics_router)
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro-debugging-with-cargo-expand"><a class="header" href="#macro-debugging-with-cargo-expand">Macro Debugging with <code>cargo expand</code></a></h1>
<p>R2E relies heavily on proc macros to generate boilerplate. When things go wrong, seeing the generated code is invaluable. <code>cargo expand</code> shows you exactly what the macros produce.</p>
<h2 id="setup-6"><a class="header" href="#setup-6">Setup</a></h2>
<p>Install <code>cargo-expand</code>:</p>
<pre><code class="language-bash">cargo install cargo-expand
</code></pre>
<p>Usage:</p>
<pre><code class="language-bash"># Expand an entire crate
cargo expand -p example-app

# Expand a single module
cargo expand -p example-app controllers::user_controller

# Filter for R2E-generated items
cargo expand -p example-app 2&gt;/dev/null | grep "__r2e_"
</code></pre>
<h2 id="what-derivecontroller-generates"><a class="header" href="#what-derivecontroller-generates">What <code>#[derive(Controller)]</code> generates</a></h2>
<p>Given this controller:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Controller)]
#[controller(path = "/users", state = AppState)]
pub struct UserController {
    #[inject] user_service: UserService,
    #[inject] event_bus: EventBus,
}
<span class="boring">}</span></code></pre>
<p>The derive produces <strong>three items</strong>:</p>
<h3 id="1-metadata-module-__r2e_meta_usercontroller"><a class="header" href="#1-metadata-module-__r2e_meta_usercontroller">1. Metadata module <code>__r2e_meta_UserController</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(hidden)]
mod __r2e_meta_UserController {
    use super::*;
    pub type State = AppState;
    pub const PATH_PREFIX: Option&lt;&amp;str&gt; = Some("/users");
    pub type IdentityType = r2e::NoIdentity;  // no #[inject(identity)] field

    pub fn guard_identity(_ctrl: &amp;super::UserController) -&gt; Option&lt;&amp;r2e::NoIdentity&gt; {
        None
    }

    pub fn validate_config(_config: &amp;r2e::config::R2eConfig) -&gt; Vec&lt;r2e::config::MissingKeyError&gt; {
        Vec::new()
    }
}
<span class="boring">}</span></code></pre>
<p>This module is referenced by <code>#[routes]</code> through naming convention. It tells the routes macro what state type to use, what the path prefix is, and what identity type is available for guards.</p>
<h3 id="2-extractor-struct-__r2eextract_usercontroller"><a class="header" href="#2-extractor-struct-__r2eextract_usercontroller">2. Extractor struct <code>__R2eExtract_UserController</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(hidden)]
pub struct __R2eExtract_UserController(pub UserController);

impl r2e::http::extract::FromRequestParts&lt;AppState&gt; for __R2eExtract_UserController {
    type Rejection = r2e::http::response::Response;

    async fn from_request_parts(
        __parts: &amp;mut r2e::http::header::Parts,
        __state: &amp;AppState,
    ) -&gt; Result&lt;Self, Self::Rejection&gt; {
        Ok(Self(UserController {
            user_service: __state.user_service.clone(),
            event_bus: __state.event_bus.clone(),
        }))
    }
}
<span class="boring">}</span></code></pre>
<p>Each <code>#[inject]</code> field is cloned from the corresponding field on the state struct. Identity fields (<code>#[inject(identity)]</code>) use Axum’s <code>FromRequestParts</code> instead.</p>
<h3 id="3-statefulconstruct-impl"><a class="header" href="#3-statefulconstruct-impl">3. <code>StatefulConstruct</code> impl</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl r2e::StatefulConstruct&lt;AppState&gt; for UserController {
    fn from_state(__state: &amp;AppState) -&gt; Self {
        Self {
            user_service: __state.user_service.clone(),
            event_bus: __state.event_bus.clone(),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>This is only generated when there are <strong>no</strong> <code>#[inject(identity)]</code> struct fields. It enables the controller to be used with <code>#[consumer]</code> and <code>#[scheduled]</code> methods that run outside of HTTP requests.</p>
<h2 id="what-routes-generates"><a class="header" href="#what-routes-generates">What <code>#[routes]</code> generates</a></h2>
<p>Given:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[routes]
impl UserController {
    #[get("/")]
    async fn list(&amp;self) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
        Json(self.user_service.list().await)
    }

    #[get("/{id}")]
    #[roles("admin")]
    async fn get_by_id(&amp;self, Path(id): Path&lt;i64&gt;) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="plain-handler"><a class="header" href="#plain-handler">Plain handler</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn __r2e_UserController_list(
    __R2eExtract_UserController(__ctrl): __R2eExtract_UserController,
) -&gt; Json&lt;Vec&lt;User&gt;&gt; {
    __ctrl.list().await
}
<span class="boring">}</span></code></pre>
<p>The extractor constructs the controller from state, then the handler delegates to the method.</p>
<h3 id="guarded-handler-with-roles"><a class="header" href="#guarded-handler-with-roles">Guarded handler (with <code>#[roles]</code>)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn __r2e_UserController_get_by_id(
    axum::extract::State(__state): axum::extract::State&lt;AppState&gt;,
    __headers: axum::http::HeaderMap,
    __uri: axum::http::Uri,
    __R2eExtract_UserController(__ctrl): __R2eExtract_UserController,
    Path(id): Path&lt;i64&gt;,
) -&gt; Result&lt;Json&lt;User&gt;, AppError&gt; {
    // Guard check runs before method body
    let __identity_ref = __r2e_meta_UserController::guard_identity(&amp;__ctrl);
    let __guard_ctx = r2e::GuardContext::new(
        "get_by_id",
        "UserController",
        &amp;__headers,
        &amp;__uri,
        __identity_ref,
    );
    r2e::Guard::check(&amp;r2e::RolesGuard::new(&amp;["admin"]), &amp;__state, &amp;__guard_ctx)
        .await
        .map_err(/* ... */)?;

    // Original method body
    __ctrl.get_by_id(Path(id)).await
}
<span class="boring">}</span></code></pre>
<p>Guarded handlers also extract <code>State</code>, <code>HeaderMap</code>, and <code>Uri</code> to build a <code>GuardContext</code>.</p>
<h3 id="controllerappstate-impl"><a class="header" href="#controllerappstate-impl"><code>Controller&lt;AppState&gt;</code> impl</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl r2e::Controller&lt;AppState&gt; for UserController {
    fn routes() -&gt; axum::Router&lt;AppState&gt; {
        axum::Router::new()
            .route("/users/", axum::routing::get(__r2e_UserController_list))
            .route("/users/{id}", axum::routing::get(__r2e_UserController_get_by_id))
    }

    fn register_meta(registry: &amp;mut r2e::MetaRegistry) { /* ... */ }

    fn scheduled_tasks(_state: &amp;AppState) -&gt; Vec&lt;r2e::scheduling::ScheduledTaskDef&lt;AppState&gt;&gt; {
        vec![]
    }
}
<span class="boring">}</span></code></pre>
<h2 id="what-bean-generates"><a class="header" href="#what-bean-generates">What <code>#[bean]</code> generates</a></h2>
<h3 id="sync-bean"><a class="header" href="#sync-bean">Sync bean</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bean]
impl UserService {
    fn new(event_bus: EventBus) -&gt; Self { Self { event_bus } }
}
<span class="boring">}</span></code></pre>
<p>Generates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl r2e::beans::Bean for UserService {
    fn dependencies() -&gt; Vec&lt;(std::any::TypeId, &amp;'static str)&gt; {
        vec![(std::any::TypeId::of::&lt;EventBus&gt;(), std::any::type_name::&lt;EventBus&gt;())]
    }

    fn build(ctx: &amp;r2e::beans::BeanContext) -&gt; Self {
        let __arg_0: EventBus = ctx.get::&lt;EventBus&gt;();
        UserService::new(__arg_0)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="async-bean"><a class="header" href="#async-bean">Async bean</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bean]
impl DbService {
    async fn new(pool: SqlitePool) -&gt; Self { Self { pool } }
}
<span class="boring">}</span></code></pre>
<p>Generates <code>impl AsyncBean</code> with an <code>async fn build(ctx)</code> instead.</p>
<h2 id="what-producer-generates"><a class="header" href="#what-producer-generates">What <code>#[producer]</code> generates</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[producer]
async fn create_pool(#[config("app.db.url")] url: String) -&gt; SqlitePool {
    SqlitePool::connect(&amp;url).await.unwrap()
}
<span class="boring">}</span></code></pre>
<p>Generates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Original function (with #[config] stripped)
async fn create_pool(url: String) -&gt; SqlitePool {
    SqlitePool::connect(&amp;url).await.unwrap()
}

// Generated struct
pub struct CreatePool;

impl r2e::beans::Producer for CreatePool {
    type Output = SqlitePool;

    fn dependencies() -&gt; Vec&lt;(std::any::TypeId, &amp;'static str)&gt; {
        vec![(std::any::TypeId::of::&lt;r2e::config::R2eConfig&gt;(), /* ... */)]
    }

    async fn produce(ctx: &amp;r2e::beans::BeanContext) -&gt; Self::Output {
        let __r2e_config: r2e::config::R2eConfig = ctx.get::&lt;r2e::config::R2eConfig&gt;();
        let __arg_0: String = __r2e_config.get::&lt;String&gt;("app.db.url").unwrap_or_else(|_| {
            panic!("Configuration error in producer `CreatePool`: key 'app.db.url' ...")
        });
        create_pool(__arg_0).await
    }
}
<span class="boring">}</span></code></pre>
<p>The function name is converted to PascalCase for the struct name (<code>create_pool</code> -&gt; <code>CreatePool</code>).</p>
<h2 id="scheduled-and-consumer"><a class="header" href="#scheduled-and-consumer"><code>#[scheduled]</code> and <code>#[consumer]</code></a></h2>
<p>These contribute to the <code>Controller</code> trait impl generated by <code>#[routes]</code>:</p>
<ul>
<li><code>#[scheduled(every = 30)]</code> methods appear in <code>scheduled_tasks()</code> as <code>ScheduledTaskDef</code> entries</li>
<li><code>#[consumer(bus = "event_bus")]</code> methods are wired up in <code>register_event_consumers()</code></li>
</ul>
<p>Both require <code>StatefulConstruct</code> (i.e. no struct-level <code>#[inject(identity)]</code>).</p>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging tips</a></h2>
<h3 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common error patterns</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error message</th><th>Cause</th><th>Fix</th></tr>
</thead>
<tbody>
<tr><td><code>cannot find __R2eExtract_X</code></td><td>Missing <code>#[derive(Controller)]</code> on the struct</td><td>Add <code>#[derive(Controller)]</code></td></tr>
<tr><td><code>StatefulConstruct is not implemented</code></td><td>Struct has <code>#[inject(identity)]</code> field</td><td>Use param-level <code>#[inject(identity)]</code> on individual handlers instead</td></tr>
<tr><td><code>#[controller(state = ...)] is required</code></td><td>Missing <code>state</code> in controller attribute</td><td>Add <code>#[controller(state = AppState)]</code></td></tr>
<tr><td><code>every controller field must be annotated</code></td><td>Field without <code>#[inject]</code>, <code>#[config]</code>, etc.</td><td>Annotate the field with one of the supported attributes</td></tr>
</tbody>
</table>
</div>
<h3 id="filtering-expanded-output"><a class="header" href="#filtering-expanded-output">Filtering expanded output</a></h3>
<p>The expanded output can be very long. Filter for R2E-generated items:</p>
<pre><code class="language-bash"># Find all generated handler functions
cargo expand -p my-app 2&gt;/dev/null | grep "fn __r2e_"

# Find all generated modules
cargo expand -p my-app 2&gt;/dev/null | grep "mod __r2e_meta_"

# Find all Controller trait impls
cargo expand -p my-app 2&gt;/dev/null | grep "impl.*Controller.*for"
</code></pre>
<h3 id="expand-a-single-controller"><a class="header" href="#expand-a-single-controller">Expand a single controller</a></h3>
<p>If you know your controller is in <code>src/controllers/user_controller.rs</code>:</p>
<pre><code class="language-bash">cargo expand -p my-app controllers::user_controller
</code></pre>
<p>This limits output to just that module, making it much easier to read.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="managed-resources"><a class="header" href="#managed-resources">Managed Resources</a></h1>
<p>The <code>#[managed]</code> attribute enables automatic lifecycle management for resources that need acquire/release semantics — transactions, connections, scoped caches, or audit contexts.</p>
<h2 id="the-managedresource-trait"><a class="header" href="#the-managedresource-trait">The <code>ManagedResource</code> trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ManagedResource&lt;S&gt;: Sized {
    type Error: Into&lt;Response&gt;;

    async fn acquire(state: &amp;S) -&gt; Result&lt;Self, Self::Error&gt;;
    async fn release(self, success: bool) -&gt; Result&lt;(), Self::Error&gt;;
}
<span class="boring">}</span></code></pre>
<ul>
<li><code>acquire()</code> — called before the handler, obtains the resource from app state</li>
<li><code>release()</code> — called after the handler, commits or rolls back
<ul>
<li><code>success = true</code> — handler returned <code>Ok</code> or a non-Result type</li>
<li><code>success = false</code> — handler returned <code>Err</code></li>
</ul>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[post("/")]
async fn create(
    &amp;self,
    body: Json&lt;CreateUserRequest&gt;,
    #[managed] tx: &amp;mut Tx&lt;'_, Sqlite&gt;,
) -&gt; Result&lt;Json&lt;User&gt;, MyAppError&gt; {
    sqlx::query("INSERT INTO users (name, email) VALUES (?, ?)")
        .bind(&amp;body.name)
        .bind(&amp;body.email)
        .execute(tx.as_mut())
        .await?;

    Ok(Json(user))
}
<span class="boring">}</span></code></pre>
<h2 id="implementing-for-transactions"><a class="header" href="#implementing-for-transactions">Implementing for transactions</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_core::{ManagedResource, ManagedErr};
use r2e::r2e_data_sqlx::HasPool;
use sqlx::{Database, Transaction, Pool};

pub struct Tx&lt;'a, DB: Database&gt;(pub Transaction&lt;'a, DB&gt;);

impl&lt;S, DB&gt; ManagedResource&lt;S&gt; for Tx&lt;'static, DB&gt;
where
    DB: Database,
    S: HasPool&lt;DB&gt; + Send + Sync,
{
    type Error = ManagedErr&lt;MyAppError&gt;;

    async fn acquire(state: &amp;S) -&gt; Result&lt;Self, Self::Error&gt; {
        let tx = state.pool().begin().await
            .map_err(|e| ManagedErr(MyAppError::Database(e.to_string())))?;
        Ok(Tx(tx))
    }

    async fn release(self, success: bool) -&gt; Result&lt;(), Self::Error&gt; {
        if success {
            self.0.commit().await
                .map_err(|e| ManagedErr(MyAppError::Database(e.to_string())))?;
        }
        // On failure: transaction dropped → automatic rollback
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-wrappers-1"><a class="header" href="#error-wrappers-1">Error wrappers</a></h2>
<p><code>ManagedResource::Error</code> must implement <code>Into&lt;Response&gt;</code>. Rust’s orphan rules prevent implementing foreign traits for foreign types, so R2E provides wrappers:</p>
<ul>
<li><code>ManagedError</code> — wraps the built-in <code>AppError</code></li>
<li><code>ManagedErr&lt;E&gt;</code> — wraps any error type implementing <code>IntoResponse</code></li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chain: MyAppError → ManagedErr&lt;MyAppError&gt; → Response
type Error = ManagedErr&lt;MyAppError&gt;;
<span class="boring">}</span></code></pre>
<h2 id="other-resource-types"><a class="header" href="#other-resource-types">Other resource types</a></h2>
<p>The pattern extends beyond transactions:</p>
<h3 id="audit-context"><a class="header" href="#audit-context">Audit context</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuditContext {
    started_at: Instant,
    action: String,
}

impl&lt;S: Send + Sync&gt; ManagedResource&lt;S&gt; for AuditContext {
    type Error = ManagedError;

    async fn acquire(_state: &amp;S) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(AuditContext {
            started_at: Instant::now(),
            action: String::new(),
        })
    }

    async fn release(self, success: bool) -&gt; Result&lt;(), Self::Error&gt; {
        let duration = self.started_at.elapsed();
        tracing::info!(
            action = self.action,
            success,
            duration_ms = duration.as_millis(),
            "Audit: action completed"
        );
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h2 id="comparison-with-transactional"><a class="header" href="#comparison-with-transactional">Comparison with <code>#[transactional]</code></a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th><code>#[managed]</code></th><th><code>#[transactional]</code></th></tr>
</thead>
<tbody>
<tr><td>Explicit parameter</td><td>Yes (<code>&amp;mut Tx</code>)</td><td>No (wraps <code>self.pool</code>)</td></tr>
<tr><td>Custom resource types</td><td>Yes</td><td>No (transactions only)</td></tr>
<tr><td>Error handling</td><td>Configurable via trait</td><td>Fixed</td></tr>
<tr><td>Flexibility</td><td>High</td><td>Convenient</td></tr>
</tbody>
</table>
</div>
<p>Prefer <code>#[managed]</code> for new code.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lifecycle-hooks"><a class="header" href="#lifecycle-hooks">Lifecycle Hooks</a></h1>
<p>R2E provides <code>on_start</code> and <code>on_stop</code> hooks for running code during application startup and shutdown.</p>
<h2 id="on_start--startup-hook"><a class="header" href="#on_start--startup-hook"><code>on_start</code> — Startup hook</a></h2>
<p>Runs before the server starts listening. Receives the application state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .on_start(|state| async move {
        // Verify database connectivity
        sqlx::query("SELECT 1").execute(&amp;state.pool).await?;
        tracing::info!("Database connection verified");
        Ok(())
    })
    // ...
<span class="boring">}</span></code></pre>
<h3 id="failure-handling"><a class="header" href="#failure-handling">Failure handling</a></h3>
<p><code>on_start</code> returns <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. If any startup hook fails, the application terminates immediately — the server never binds:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_start(|state| async move {
    if !state.config.get::&lt;bool&gt;("app.ready").unwrap_or(false) {
        return Err("Application not ready".into());
    }
    Ok(())
})
<span class="boring">}</span></code></pre>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common use cases</a></h3>
<ul>
<li>Database connectivity checks</li>
<li>Running migrations (<code>sqlx::migrate!().run(&amp;pool).await</code>)</li>
<li>Cache preloading</li>
<li>Configuration validation</li>
<li>JWKS key pre-warming</li>
</ul>
<h2 id="on_stop--shutdown-hook"><a class="header" href="#on_stop--shutdown-hook"><code>on_stop</code> — Shutdown hook</a></h2>
<p>Runs after the server stops accepting connections and all in-flight requests complete:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_stop(|| async {
    tracing::info!("Shutdown in progress");
    // Flush logs, close connections, notify monitoring
})
<span class="boring">}</span></code></pre>
<p>Shutdown hooks don’t return <code>Result</code> — there’s no meaningful way to handle errors during shutdown.</p>
<h3 id="common-use-cases-1"><a class="header" href="#common-use-cases-1">Common use cases</a></h3>
<ul>
<li>Flushing metrics/logs</li>
<li>Closing external connections</li>
<li>Notifying monitoring systems</li>
<li>Saving in-memory state</li>
</ul>
<h2 id="multiple-hooks"><a class="header" href="#multiple-hooks">Multiple hooks</a></h2>
<p>Register multiple hooks — they execute in registration order:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .on_start(|state| async move {
        tracing::info!("Hook 1: check DB");
        Ok(())
    })
    .on_start(|state| async move {
        tracing::info!("Hook 2: warm cache");
        Ok(())
    })
    .on_stop(|| async {
        tracing::info!("Hook 1: flush logs");
    })
    .on_stop(|| async {
        tracing::info!("Hook 2: close connections");
    })
    // ...
<span class="boring">}</span></code></pre>
<h2 id="execution-sequence"><a class="header" href="#execution-sequence">Execution sequence</a></h2>
<pre><code>on_start hooks (in order)
    ↓ (if all succeed)
TCP bind
    ↓
Serve requests
    ↓ (Ctrl-C / SIGTERM)
Stop accepting connections
    ↓
Wait for in-flight requests
    ↓
on_stop hooks (in order)
    ↓
Process exit
</code></pre>
<p>If any <code>on_start</code> hook fails, execution stops immediately — later hooks and the server don’t run.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dev-mode"><a class="header" href="#dev-mode">Dev Mode</a></h1>
<p>R2E provides development-mode endpoints for hot-reload detection and diagnostics.</p>
<h2 id="enabling-dev-mode"><a class="header" href="#enabling-dev-mode">Enabling dev mode</a></h2>
<p>Add the <code>DevReload</code> plugin:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(DevReload)
    // ...
<span class="boring">}</span></code></pre>
<h2 id="dev-endpoints"><a class="header" href="#dev-endpoints">Dev endpoints</a></h2>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<pre><code>GET /__r2e_dev/status → "dev"
</code></pre>
<p>Returns plain text <code>"dev"</code>. Use to check if the server is running in development mode.</p>
<h3 id="ping"><a class="header" href="#ping">Ping</a></h3>
<pre><code>GET /__r2e_dev/ping → {"boot_time": 1234567890123, "status": "ok"}
</code></pre>
<p>Returns the server’s boot timestamp (milliseconds since epoch). Use to detect server restarts.</p>
<h2 id="hot-reload-workflow"><a class="header" href="#hot-reload-workflow">Hot-reload workflow</a></h2>
<ol>
<li>Use <code>cargo watch</code> (or <code>r2e dev</code>) to auto-restart on file changes</li>
<li>Client-side JavaScript polls <code>/__r2e_dev/ping</code></li>
<li>When <code>boot_time</code> changes, a restart occurred → refresh the page</li>
</ol>
<pre><code>Source code change
    → cargo-watch detects change
    → kills server process
    → rebuilds and restarts
    → new boot_time
    → client detects → page refresh
</code></pre>
<h3 id="client-side-polling-example"><a class="header" href="#client-side-polling-example">Client-side polling example</a></h3>
<pre><code class="language-javascript">let lastBootTime = null;

setInterval(async () =&gt; {
    try {
        const res = await fetch('/__r2e_dev/ping');
        const data = await res.json();

        if (lastBootTime === null) {
            lastBootTime = data.boot_time;
        } else if (data.boot_time !== lastBootTime) {
            location.reload();
        }
    } catch {
        // Server is restarting, wait for next poll
    }
}, 1000);
</code></pre>
<h2 id="using-r2e-dev"><a class="header" href="#using-r2e-dev">Using <code>r2e dev</code></a></h2>
<p>The CLI provides a convenient wrapper:</p>
<pre><code class="language-bash">r2e dev
</code></pre>
<p>This:</p>
<ul>
<li>Sets <code>R2E_PROFILE=dev</code></li>
<li>Watches <code>src/</code>, <code>application.yaml</code>, <code>application-dev.yaml</code>, <code>migrations/</code></li>
<li>Prints discovered routes</li>
<li>Auto-restarts on changes</li>
</ul>
<p>Add <code>--open</code> to auto-open the browser:</p>
<pre><code class="language-bash">r2e dev --open
</code></pre>
<h2 id="production-note"><a class="header" href="#production-note">Production note</a></h2>
<p>Do <strong>not</strong> enable <code>DevReload</code> in production. The dev endpoints are informational only but expose internal details (boot time) that shouldn’t be public.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(debug_assertions)]
builder = builder.with(DevReload);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="openapi"><a class="header" href="#openapi">OpenAPI</a></h1>
<p>R2E auto-generates an OpenAPI 3.0.3 specification from your controller route metadata, with an optional interactive documentation UI.</p>
<h2 id="setup-7"><a class="header" href="#setup-7">Setup</a></h2>
<p>Enable the openapi feature:</p>
<pre><code class="language-toml">r2e = { version = "0.1", features = ["openapi"] }
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::r2e_openapi::{OpenApiConfig, OpenApiPlugin};

AppBuilder::new()
    .build_state::&lt;AppState, _&gt;()
    .await
    .with(OpenApiPlugin::new(
        OpenApiConfig::new("My API", "1.0.0")
            .with_description("API description")
            .with_docs_ui(true),
    ))
    .register_controller::&lt;UserController&gt;()
    .serve("0.0.0.0:3000")
    .await
    .unwrap();
<span class="boring">}</span></code></pre>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Endpoint</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>GET /openapi.json</code></td><td>OpenAPI 3.0.3 specification</td></tr>
<tr><td><code>GET /docs</code></td><td>Interactive API documentation (if <code>with_docs_ui(true)</code>)</td></tr>
</tbody>
</table>
</div>
<h2 id="what-gets-documented"><a class="header" href="#what-gets-documented">What gets documented</a></h2>
<p>Route metadata is automatically collected from <code>Controller::route_metadata()</code> during <code>register_controller()</code>:</p>
<ul>
<li><strong>Paths</strong> — from <code>#[controller(path = "...")]</code> + <code>#[get("/...")]</code></li>
<li><strong>HTTP methods</strong> — GET, POST, PUT, DELETE, PATCH</li>
<li><strong>Path parameters</strong> — from <code>{param}</code> in paths</li>
<li><strong>Required roles</strong> — from <code>#[roles("...")]</code></li>
<li><strong>Operation IDs</strong> — from handler method names</li>
</ul>
<h2 id="openapiconfig-options"><a class="header" href="#openapiconfig-options">OpenApiConfig options</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>new(title, version)</code></td><td>Create config with title and version</td></tr>
<tr><td><code>with_description(desc)</code></td><td>Set API description</td></tr>
<tr><td><code>with_docs_ui(true)</code></td><td>Enable interactive docs at <code>/docs</code></td></tr>
</tbody>
</table>
</div>
<h2 id="example-spec-output"><a class="header" href="#example-spec-output">Example spec output</a></h2>
<pre><code class="language-json">{
  "openapi": "3.0.3",
  "info": {
    "title": "My API",
    "version": "1.0.0",
    "description": "API description"
  },
  "paths": {
    "/users": {
      "get": {
        "operationId": "list",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        }
      },
      "post": {
        "operationId": "create",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "security": [{"roles": ["admin"]}]
      }
    },
    "/users/{id}": {
      "get": {
        "operationId": "get_by_id",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {"type": "string"}
          }
        ]
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-guide"><a class="header" href="#performance-guide">Performance Guide</a></h1>
<p>R2E is designed for minimal overhead. Understanding the cost model helps you make informed decisions.</p>
<h2 id="per-request-cost-breakdown"><a class="header" href="#per-request-cost-breakdown">Per-request cost breakdown</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Cost</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Tower layer traversal</td><td>~1 us</td><td>TraceLayer, CorsLayer, etc.</td></tr>
<tr><td>Axum routing</td><td>~1 us</td><td>Path matching</td></tr>
<tr><td><code>#[inject]</code> field clone</td><td>~10-50 ns each</td><td>O(1) if <code>Arc</code></td></tr>
<tr><td><code>#[config("key")]</code> lookup</td><td>~50 ns each</td><td>HashMap lookup</td></tr>
<tr><td>JWT validation</td><td>~10-50 us</td><td>Signature verification</td></tr>
<tr><td>JWKS lookup (cache miss)</td><td>~50-200 ms</td><td>HTTP roundtrip (rare)</td></tr>
<tr><td>Rate limit check</td><td>~100 ns</td><td>DashMap lookup</td></tr>
<tr><td>Role guard check</td><td>~50 ns</td><td>Vec scan</td></tr>
<tr><td>Interceptor overhead</td><td>~100 ns each</td><td>Monomorphized, no vtable</td></tr>
<tr><td>Business logic</td><td>variable</td><td>DB I/O, external services</td></tr>
</tbody>
</table>
</div>
<h2 id="optimization-guidelines"><a class="header" href="#optimization-guidelines">Optimization guidelines</a></h2>
<h3 id="1-wrap-services-in-arc"><a class="header" href="#1-wrap-services-in-arc">1. Wrap services in <code>Arc</code></a></h3>
<p>Service clones happen per request. With <code>Arc</code>, it’s a reference count increment (~10 ns) vs a deep copy:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
pub struct UserService {
    inner: Arc&lt;UserServiceInner&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="2-use-param-level-identity-for-mixed-controllers"><a class="header" href="#2-use-param-level-identity-for-mixed-controllers">2. Use param-level identity for mixed controllers</a></h3>
<p>Struct-level <code>#[inject(identity)]</code> runs JWT validation for <strong>every</strong> endpoint — even public ones. Param-level only validates when needed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: JWT validated for public endpoints too
#[derive(Controller)]
pub struct ApiController {
    #[inject(identity)] user: AuthenticatedUser,  // validates on ALL endpoints
}

// Good: JWT only validated where needed
#[derive(Controller)]
pub struct ApiController {
    #[inject] service: MyService,
}

#[routes]
impl ApiController {
    #[get("/public")]
    async fn public_data(&amp;self) -&gt; Json&lt;Data&gt; { /* no JWT overhead */ }

    #[get("/me")]
    async fn me(&amp;self, #[inject(identity)] user: AuthenticatedUser) -&gt; Json&lt;User&gt; {
        Json(user)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="3-minimize-config-fields"><a class="header" href="#3-minimize-config-fields">3. Minimize <code>#[config]</code> fields</a></h3>
<p>Each <code>#[config]</code> field performs a HashMap lookup per request. For frequently accessed config, consider caching the value in a service field at startup.</p>
<h3 id="4-pre-warm-jwks-cache"><a class="header" href="#4-pre-warm-jwks-cache">4. Pre-warm JWKS cache</a></h3>
<p>The first JWT validation with a JWKS endpoint incurs a ~50-200 ms HTTP roundtrip. Pre-warm in an <code>on_start</code> hook:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_start(|state| async move {
    // Trigger a JWKS cache refresh
    state.validator.refresh_jwks().await?;
    Ok(())
})
<span class="boring">}</span></code></pre>
<h3 id="5-interceptors-are-free"><a class="header" href="#5-interceptors-are-free">5. Interceptors are free</a></h3>
<p>Interceptors use monomorphization (no <code>dyn</code>, no vtable). The overhead is ~100 ns — effectively free. Don’t hesitate to use <code>Logged</code>, <code>Timed</code>, etc.</p>
<h3 id="6-guards-should-be-o1"><a class="header" href="#6-guards-should-be-o1">6. Guards should be O(1)</a></h3>
<p>Guards run on every guarded request. Keep them fast:</p>
<ul>
<li>Role checks: O(n) where n = number of required roles (typically small)</li>
<li>Rate limit checks: O(1) DashMap lookup</li>
<li>Avoid database queries in guards when possible</li>
</ul>
<h3 id="7-one-controller-per-responsibility"><a class="header" href="#7-one-controller-per-responsibility">7. One controller per responsibility</a></h3>
<p>Avoid putting unrelated endpoints in the same controller. Each controller shares the same injection profile — injecting unnecessary services adds clone overhead.</p>
<h2 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-patterns</a></h2>
<h3 id="storing-r2econfig-as-inject"><a class="header" href="#storing-r2econfig-as-inject">Storing <code>R2eConfig</code> as <code>#[inject]</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: clones the entire config HashMap per request
#[inject] config: R2eConfig,

// Good: use specific #[config] fields
#[config("app.name")] name: String,
<span class="boring">}</span></code></pre>
<h3 id="io-in-custom-guards"><a class="header" href="#io-in-custom-guards">I/O in custom guards</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: blocks the Tokio runtime
impl&lt;S, I: Identity&gt; Guard&lt;S, I&gt; for SlowGuard {
    fn check(&amp;self, state: &amp;S, ctx: &amp;GuardContext&lt;'_, I&gt;) -&gt; impl Future&lt;...&gt; + Send {
        async move {
            // This is a database query on EVERY request
            let result = sqlx::query("SELECT ...").fetch_one(&amp;pool).await;
            // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<p>If you must do I/O in guards, consider caching results or moving the check to the handler body.</p>
<h2 id="comparison-struct-level-vs-param-level-identity"><a class="header" href="#comparison-struct-level-vs-param-level-identity">Comparison: struct-level vs param-level identity</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Struct-level</th><th>Param-level</th></tr>
</thead>
<tbody>
<tr><td>JWT validation</td><td>Every request</td><td>Only annotated endpoints</td></tr>
<tr><td><code>StatefulConstruct</code></td><td>Not generated</td><td>Generated</td></tr>
<tr><td>Consumers/Schedulers</td><td>Not possible</td><td>Possible</td></tr>
<tr><td>Identity access</td><td><code>self.user</code></td><td>Only in handler parameter</td></tr>
<tr><td>Public endpoint overhead</td><td>JWT validation wasted</td><td>None</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="test-setup"><a class="header" href="#test-setup">Test Setup</a></h1>
<p>R2E provides <code>r2e-test</code> with utilities for integration testing.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
r2e-test = "0.1"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="basic-test-structure"><a class="header" href="#basic-test-structure">Basic test structure</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;
use r2e_test::{TestApp, TestJwt};

async fn setup() -&gt; (TestApp, TestJwt) {
    let jwt = TestJwt::new();

    // Build app state for testing
    let app = TestApp::from_builder(
        AppBuilder::new()
            .provide(Arc::new(jwt.claims_validator()))
            .with_bean::&lt;UserService&gt;()
            .build_state::&lt;AppState, _&gt;()
            .await
            .with(Health)
            .with(ErrorHandling)
            .register_controller::&lt;UserController&gt;(),
    );

    (app, jwt)
}

#[tokio::test]
async fn test_health_check() {
    let (app, _) = setup().await;
    app.get("/health").await.assert_ok();
}
<span class="boring">}</span></code></pre>
<h2 id="key-pattern-testappfrom_builder"><a class="header" href="#key-pattern-testappfrom_builder">Key pattern: <code>TestApp::from_builder</code></a></h2>
<p><code>TestApp</code> wraps your router with an in-process HTTP client (via <code>tower::ServiceExt::oneshot</code> — no TCP). This means:</p>
<ul>
<li>Tests run fast (no network overhead)</li>
<li>No port conflicts</li>
<li>Full request/response lifecycle</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let app = TestApp::from_builder(
    AppBuilder::new()
        // ... same setup as your main.rs, but with test fixtures
        .register_controller::&lt;UserController&gt;(),
);
<span class="boring">}</span></code></pre>
<h2 id="test-configuration"><a class="header" href="#test-configuration">Test configuration</a></h2>
<p>For tests, use <code>R2eConfig::empty()</code> or manual config:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = R2eConfig::empty();
config.set("app.name", ConfigValue::String("test-app".into()));
<span class="boring">}</span></code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<pre><code class="language-bash">cargo test --workspace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testapp"><a class="header" href="#testapp">TestApp</a></h1>
<p><code>TestApp</code> provides an HTTP client for integration testing without starting a TCP server.</p>
<h2 id="creating-a-testapp"><a class="header" href="#creating-a-testapp">Creating a TestApp</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_test::TestApp;

let app = TestApp::from_builder(
    AppBuilder::new()
        .build_state::&lt;AppState, _&gt;()
        .await
        .register_controller::&lt;UserController&gt;(),
);
<span class="boring">}</span></code></pre>
<h2 id="http-methods"><a class="header" href="#http-methods">HTTP methods</a></h2>
<h3 id="unauthenticated-requests"><a class="header" href="#unauthenticated-requests">Unauthenticated requests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET
let resp = app.get("/users").await;

// POST with JSON
let resp = app.post_json("/users", &amp;serde_json::json!({
    "name": "Alice",
    "email": "alice@example.com"
})).await;
<span class="boring">}</span></code></pre>
<h3 id="authenticated-requests"><a class="header" href="#authenticated-requests">Authenticated requests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let jwt = TestJwt::new();
let token = jwt.token("user-1", &amp;["user"]);

// GET with auth
let resp = app.get_authenticated("/users", &amp;token).await;

// POST with auth
let resp = app.post_json_authenticated("/users", &amp;body, &amp;token).await;

// PUT with auth
let resp = app.put_json_authenticated("/users/1", &amp;body, &amp;token).await;

// DELETE with auth
let resp = app.delete_authenticated("/users/1", &amp;token).await;
<span class="boring">}</span></code></pre>
<h2 id="testresponse"><a class="header" href="#testresponse">TestResponse</a></h2>
<p>All methods return a <code>TestResponse</code> with assertion helpers:</p>
<h3 id="status-assertions"><a class="header" href="#status-assertions">Status assertions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>resp.assert_ok();           // 200
resp.assert_unauthorized();  // 401
resp.assert_forbidden();     // 403
resp.assert_bad_request();   // 400
resp.assert_status(StatusCode::CREATED);  // custom status
<span class="boring">}</span></code></pre>
<h3 id="body-access"><a class="header" href="#body-access">Body access</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Deserialize JSON
let users: Vec&lt;User&gt; = resp.json();

// Raw text
let body: String = resp.text();
<span class="boring">}</span></code></pre>
<h3 id="chaining"><a class="header" href="#chaining">Chaining</a></h3>
<p>Assertions return the response for chaining:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users: Vec&lt;User&gt; = app
    .get_authenticated("/users", &amp;token)
    .await
    .assert_ok()
    .json();
<span class="boring">}</span></code></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_crud_flow() {
    let (app, jwt) = setup().await;
    let token = jwt.token("user-1", &amp;["admin"]);

    // List users
    let users: Vec&lt;User&gt; = app
        .get_authenticated("/users", &amp;token)
        .await
        .assert_ok()
        .json();
    assert_eq!(users.len(), 2);

    // Create user
    let new_user: User = app
        .post_json_authenticated("/users", &amp;serde_json::json!({
            "name": "Charlie",
            "email": "charlie@example.com"
        }), &amp;token)
        .await
        .assert_ok()
        .json();
    assert_eq!(new_user.name, "Charlie");

    // Verify creation
    let users: Vec&lt;User&gt; = app
        .get_authenticated("/users", &amp;token)
        .await
        .assert_ok()
        .json();
    assert_eq!(users.len(), 3);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testjwt"><a class="header" href="#testjwt">TestJwt</a></h1>
<p><code>TestJwt</code> generates valid JWT tokens for testing, with configurable claims.</p>
<h2 id="creating-a-testjwt"><a class="header" href="#creating-a-testjwt">Creating a TestJwt</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e_test::TestJwt;

let jwt = TestJwt::new();
<span class="boring">}</span></code></pre>
<p>This creates a JWT generator with a random HMAC-SHA256 key. Tokens are valid for 1 hour.</p>
<h2 id="generating-tokens"><a class="header" href="#generating-tokens">Generating tokens</a></h2>
<h3 id="basic-token"><a class="header" href="#basic-token">Basic token</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let token = jwt.token("user-123", &amp;["user"]);
<span class="boring">}</span></code></pre>
<p>Creates a token with:</p>
<ul>
<li><code>sub</code>: <code>"user-123"</code></li>
<li><code>roles</code>: <code>["user"]</code></li>
<li><code>iss</code>, <code>aud</code>, <code>exp</code>: auto-populated</li>
</ul>
<h3 id="token-with-custom-claims"><a class="header" href="#token-with-custom-claims">Token with custom claims</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let token = jwt.token_with_claims(serde_json::json!({
    "sub": "user-123",
    "email": "alice@example.com",
    "roles": ["user", "admin"],
    "tenant_id": "acme-corp",
    "custom_field": "value",
}));
<span class="boring">}</span></code></pre>
<h2 id="getting-the-validator"><a class="header" href="#getting-the-validator">Getting the validator</a></h2>
<p><code>TestJwt</code> provides validators compatible with R2E’s security system:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For JwtValidator (higher-level)
let validator = jwt.validator();

// For JwtClaimsValidator (low-level, used by AuthenticatedUser)
let claims_validator = jwt.claims_validator();
<span class="boring">}</span></code></pre>
<h2 id="wiring-into-test-state"><a class="header" href="#wiring-into-test-state">Wiring into test state</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

async fn setup() -&gt; (TestApp, TestJwt) {
    let jwt = TestJwt::new();

    let app = TestApp::from_builder(
        AppBuilder::new()
            .provide(Arc::new(jwt.claims_validator()))
            // ...
            .build_state::&lt;AppState, _&gt;()
            .await
            .register_controller::&lt;UserController&gt;(),
    );

    (app, jwt)
}
<span class="boring">}</span></code></pre>
<h2 id="testing-different-roles"><a class="header" href="#testing-different-roles">Testing different roles</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_role_access() {
    let (app, jwt) = setup().await;

    // Regular user
    let user_token = jwt.token("user-1", &amp;["user"]);
    app.get_authenticated("/admin/panel", &amp;user_token)
        .await
        .assert_forbidden();

    // Admin user
    let admin_token = jwt.token("admin-1", &amp;["admin"]);
    app.get_authenticated("/admin/panel", &amp;admin_token)
        .await
        .assert_ok();
}
<span class="boring">}</span></code></pre>
<h2 id="testing-unauthenticated-access"><a class="header" href="#testing-unauthenticated-access">Testing unauthenticated access</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_no_auth() {
    let (app, _) = setup().await;

    // No token → 401
    app.get("/users").await.assert_unauthorized();
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h1>
<p>Common patterns for writing R2E integration tests.</p>
<h2 id="shared-setup-function"><a class="header" href="#shared-setup-function">Shared setup function</a></h2>
<p>Create a reusable setup that mirrors your production app:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use r2e::prelude::*;
use r2e_test::{TestApp, TestJwt};
use std::sync::Arc;

async fn setup() -&gt; (TestApp, TestJwt) {
    let jwt = TestJwt::new();
    let event_bus = EventBus::new();

    let app = TestApp::from_builder(
        AppBuilder::new()
            .provide(Arc::new(jwt.claims_validator()))
            .provide(event_bus)
            .with_bean::&lt;UserService&gt;()
            .build_state::&lt;AppState, _&gt;()
            .await
            .with(Health)
            .with(ErrorHandling)
            .register_controller::&lt;UserController&gt;()
            .register_controller::&lt;AccountController&gt;(),
    );

    (app, jwt)
}
<span class="boring">}</span></code></pre>
<h2 id="testing-validation"><a class="header" href="#testing-validation">Testing validation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_validation_errors() {
    let (app, jwt) = setup().await;
    let token = jwt.token("user-1", &amp;["admin"]);

    // Missing required field
    let resp = app.post_json_authenticated("/users", &amp;serde_json::json!({
        "email": "alice@example.com"
    }), &amp;token).await;
    resp.assert_bad_request();

    // Invalid email
    let resp = app.post_json_authenticated("/users", &amp;serde_json::json!({
        "name": "Alice",
        "email": "not-an-email"
    }), &amp;token).await;
    resp.assert_bad_request();
}
<span class="boring">}</span></code></pre>
<h2 id="testing-error-responses"><a class="header" href="#testing-error-responses">Testing error responses</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_not_found() {
    let (app, jwt) = setup().await;
    let token = jwt.token("user-1", &amp;["user"]);

    let resp = app.get_authenticated("/users/99999", &amp;token).await;
    resp.assert_status(StatusCode::NOT_FOUND);

    let body: serde_json::Value = resp.json();
    assert_eq!(body["error"], "User not found");
}
<span class="boring">}</span></code></pre>
<h2 id="testing-with-database"><a class="header" href="#testing-with-database">Testing with database</a></h2>
<p>For tests with SQLite:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn setup_with_db() -&gt; (TestApp, TestJwt) {
    let jwt = TestJwt::new();
    let pool = SqlitePool::connect("sqlite::memory:").await.unwrap();

    // Run migrations or create tables
    sqlx::query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)")
        .execute(&amp;pool)
        .await
        .unwrap();

    // Seed test data
    sqlx::query("INSERT INTO users (name, email) VALUES ('Alice', 'alice@test.com')")
        .execute(&amp;pool)
        .await
        .unwrap();

    let app = TestApp::from_builder(
        AppBuilder::new()
            .provide(Arc::new(jwt.claims_validator()))
            .provide(pool)
            .with_bean::&lt;UserService&gt;()
            .build_state::&lt;AppState, _&gt;()
            .await
            .with(ErrorHandling)
            .register_controller::&lt;UserController&gt;(),
    );

    (app, jwt)
}
<span class="boring">}</span></code></pre>
<h2 id="testing-rate-limiting"><a class="header" href="#testing-rate-limiting">Testing rate limiting</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_rate_limiting() {
    let (app, jwt) = setup().await;
    let token = jwt.token("user-1", &amp;["user"]);

    // Make requests up to the limit
    for _ in 0..5 {
        app.get_authenticated("/api/data", &amp;token)
            .await
            .assert_ok();
    }

    // Next request should be rate limited
    app.get_authenticated("/api/data", &amp;token)
        .await
        .assert_status(StatusCode::TOO_MANY_REQUESTS);
}
<span class="boring">}</span></code></pre>
<h2 id="testing-events"><a class="header" href="#testing-events">Testing events</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_event_emission() {
    let event_bus = EventBus::new();
    let received = Arc::new(AtomicBool::new(false));
    let received_clone = received.clone();

    event_bus.subscribe(move |_event: Arc&lt;UserCreatedEvent&gt;| {
        let received = received_clone.clone();
        async move {
            received.store(true, Ordering::SeqCst);
        }
    }).await;

    // Setup app with the event bus
    let jwt = TestJwt::new();
    let app = TestApp::from_builder(
        AppBuilder::new()
            .provide(Arc::new(jwt.claims_validator()))
            .provide(event_bus)
            .with_bean::&lt;UserService&gt;()
            .build_state::&lt;AppState, _&gt;()
            .await
            .register_controller::&lt;UserController&gt;(),
    );

    let token = jwt.token("admin-1", &amp;["admin"]);
    app.post_json_authenticated("/users", &amp;serde_json::json!({
        "name": "Alice",
        "email": "alice@test.com"
    }), &amp;token).await.assert_ok();

    // Give async event handlers time to run
    tokio::time::sleep(Duration::from_millis(100)).await;
    assert!(received.load(Ordering::SeqCst));
}
<span class="boring">}</span></code></pre>
<h2 id="testing-mixed-controllers"><a class="header" href="#testing-mixed-controllers">Testing mixed controllers</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_public_and_protected() {
    let (app, jwt) = setup().await;

    // Public endpoint works without auth
    app.get("/api/public").await.assert_ok();

    // Protected endpoint requires auth
    app.get("/api/me").await.assert_unauthorized();

    let token = jwt.token("user-1", &amp;["user"]);
    app.get_authenticated("/api/me", &amp;token).await.assert_ok();
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-map"><a class="header" href="#crate-map">Crate Map</a></h1>
<p>R2E is organized as a workspace of focused crates. The <code>r2e</code> facade crate re-exports everything with feature gates.</p>
<h2 id="crate-overview"><a class="header" href="#crate-overview">Crate overview</a></h2>
<pre><code>r2e              Facade crate — re-exports everything, feature-gated
r2e-core         Runtime: AppBuilder, Controller, guards, interceptors, config, plugins
r2e-macros       Proc macros: #[derive(Controller)], #[routes], #[bean], #[producer]
r2e-security     JWT/OIDC: AuthenticatedUser, JwtValidator, JWKS cache
r2e-events       In-process typed EventBus with pub/sub
r2e-scheduler    Background task scheduling (interval, cron)
r2e-data         Database: Entity, Repository, QueryBuilder, Pageable/Page
r2e-data-sqlx    SQLx backend: SqlxRepository, Tx, HasPool, migrations
r2e-data-diesel  Diesel backend (skeleton)
r2e-cache        TTL cache with pluggable backends
r2e-rate-limit   Token-bucket rate limiting with pluggable backends
r2e-openapi      OpenAPI 3.0.3 spec generation + docs UI
r2e-prometheus   Prometheus metrics middleware
r2e-observability Structured observability (tracing, metrics)
r2e-openfga      OpenFGA authorization integration
r2e-utils        Built-in interceptors: Logged, Timed, Cache, CacheInvalidate
r2e-test         TestApp, TestJwt for integration testing
r2e-cli          CLI scaffolding tool
</code></pre>
<h2 id="dependency-flow"><a class="header" href="#dependency-flow">Dependency flow</a></h2>
<pre><code>r2e-macros (proc-macro, no runtime deps)
    ↑
r2e-core (runtime foundation)
    ↑
r2e-security / r2e-events / r2e-scheduler / r2e-data
    ↑
r2e-data-sqlx / r2e-cache / r2e-rate-limit / r2e-openapi / r2e-utils / r2e-test
    ↑
r2e (facade)
    ↑
your application
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h2>
<p>The <code>r2e</code> facade crate gates sub-crates behind features:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Crates enabled</th></tr>
</thead>
<tbody>
<tr><td><code>security</code></td><td><code>r2e-security</code></td></tr>
<tr><td><code>events</code></td><td><code>r2e-events</code></td></tr>
<tr><td><code>scheduler</code></td><td><code>r2e-scheduler</code></td></tr>
<tr><td><code>data</code></td><td><code>r2e-data</code>, <code>r2e-data-sqlx</code></td></tr>
<tr><td><code>cache</code></td><td><code>r2e-cache</code></td></tr>
<tr><td><code>rate-limit</code></td><td><code>r2e-rate-limit</code></td></tr>
<tr><td><code>openapi</code></td><td><code>r2e-openapi</code></td></tr>
<tr><td><code>utils</code></td><td><code>r2e-utils</code></td></tr>
<tr><td><code>prometheus</code></td><td><code>r2e-prometheus</code></td></tr>
<tr><td><code>validation</code></td><td>Enables <code>Validated&lt;T&gt;</code> in <code>r2e-core</code></td></tr>
<tr><td><code>full</code></td><td>All of the above</td></tr>
</tbody>
</table>
</div>
<h2 id="using-sub-crates-directly"><a class="header" href="#using-sub-crates-directly">Using sub-crates directly</a></h2>
<p>While most applications should use the <code>r2e</code> facade, you can depend on individual crates:</p>
<pre><code class="language-toml">[dependencies]
r2e-core = "0.1"
r2e-macros = "0.1"
r2e-security = "0.1"
</code></pre>
<p>The proc macros use <code>proc-macro-crate</code> for dynamic path detection — they check for <code>r2e</code> first, then fall back to <code>r2e-core</code>. This means generated code uses <code>::r2e::</code> paths when using the facade, or <code>::r2e_core::</code> when using crates directly.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<p>The <code>r2e</code> CLI provides project scaffolding, code generation, development tools, and diagnostics.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-bash">cargo install r2e-cli
</code></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="r2e-new-name"><a class="header" href="#r2e-new-name"><code>r2e new &lt;name&gt;</code></a></h3>
<p>Create a new R2E project.</p>
<pre><code>r2e new &lt;name&gt; [options]

Options:
  --db &lt;sqlite|postgres|mysql&gt;   Include database support
  --auth                         Include JWT/OIDC security
  --openapi                      Include OpenAPI documentation
  --full                         Enable all features (SQLite + all)
  --no-interactive               Skip interactive prompts
</code></pre>
<p>Examples:</p>
<pre><code class="language-bash">r2e new my-app                          # Interactive
r2e new my-app --full                   # All features, SQLite
r2e new my-app --db postgres --auth     # Postgres + auth
r2e new my-app --no-interactive         # Minimal, no prompts
</code></pre>
<h3 id="r2e-dev"><a class="header" href="#r2e-dev"><code>r2e dev</code></a></h3>
<p>Start development server with hot-reload.</p>
<pre><code>r2e dev [options]

Options:
  --open    Open browser after startup
</code></pre>
<p>Wraps <code>cargo watch</code>. Watches <code>src/</code>, <code>application.yaml</code>, <code>application-dev.yaml</code>, <code>migrations/</code>. Sets <code>R2E_PROFILE=dev</code>. Requires <code>cargo install cargo-watch</code>.</p>
<h3 id="r2e-generate"><a class="header" href="#r2e-generate"><code>r2e generate</code></a></h3>
<p>Generate code scaffolds.</p>
<h4 id="r2e-generate-controller-name"><a class="header" href="#r2e-generate-controller-name"><code>r2e generate controller &lt;Name&gt;</code></a></h4>
<pre><code class="language-bash">r2e generate controller UserController
</code></pre>
<p>Creates <code>src/controllers/user_controller.rs</code> with a skeleton controller. Updates <code>src/controllers/mod.rs</code>.</p>
<h4 id="r2e-generate-service-name"><a class="header" href="#r2e-generate-service-name"><code>r2e generate service &lt;Name&gt;</code></a></h4>
<pre><code class="language-bash">r2e generate service UserService
</code></pre>
<p>Creates <code>src/user_service.rs</code> with a skeleton service struct.</p>
<h4 id="r2e-generate-crud-name---fields-fields"><a class="header" href="#r2e-generate-crud-name---fields-fields"><code>r2e generate crud &lt;Name&gt; --fields "&lt;fields&gt;"</code></a></h4>
<pre><code class="language-bash">r2e generate crud Article --fields "title:String body:String published:bool"
</code></pre>
<p>Generates:</p>
<ul>
<li><code>src/models/article.rs</code> — entity + request types</li>
<li><code>src/services/article_service.rs</code> — CRUD service</li>
<li><code>src/controllers/article_controller.rs</code> — REST controller</li>
<li><code>migrations/&lt;timestamp&gt;_create_articles.sql</code> — SQL migration</li>
<li><code>tests/article_test.rs</code> — test skeleton</li>
</ul>
<p>Field format: <code>name:Type</code> pairs separated by spaces. Types: <code>String</code> (→ TEXT), <code>i64</code> (→ INTEGER), <code>f64</code> (→ REAL), <code>bool</code> (→ BOOLEAN). Prefix with <code>?</code> for optional: <code>?website:String</code>.</p>
<h4 id="r2e-generate-middleware-name"><a class="header" href="#r2e-generate-middleware-name"><code>r2e generate middleware &lt;Name&gt;</code></a></h4>
<pre><code class="language-bash">r2e generate middleware AuditLog
</code></pre>
<p>Creates <code>src/middleware/audit_log.rs</code> with an <code>Interceptor&lt;R&gt;</code> implementation skeleton.</p>
<h3 id="r2e-doctor"><a class="header" href="#r2e-doctor"><code>r2e doctor</code></a></h3>
<p>Run project health checks.</p>
<pre><code class="language-bash">r2e doctor
</code></pre>
<p>Checks:</p>
<ul>
<li>Cargo.toml exists and has R2E dependency</li>
<li>Configuration file present (<code>application.yaml</code>)</li>
<li>Controllers directory exists</li>
<li>Rust toolchain available</li>
<li><code>cargo-watch</code> installed</li>
<li>Migrations directory (if data features used)</li>
<li>Application entrypoint has <code>.serve()</code> call</li>
</ul>
<h3 id="r2e-routes"><a class="header" href="#r2e-routes"><code>r2e routes</code></a></h3>
<p>List all routes from source code (no compilation).</p>
<pre><code class="language-bash">r2e routes
</code></pre>
<p>Output:</p>
<pre><code>GET     /health
GET     /users
GET     /users/{id}
POST    /users               [roles: admin]
DELETE  /users/{id}          [roles: admin]
</code></pre>
<h3 id="r2e-add-extension"><a class="header" href="#r2e-add-extension"><code>r2e add &lt;extension&gt;</code></a></h3>
<p>Add an R2E sub-crate dependency.</p>
<pre><code class="language-bash">r2e add security      # r2e-security
r2e add data          # r2e-data + r2e-data-sqlx
r2e add openapi       # r2e-openapi
r2e add events        # r2e-events
r2e add scheduler     # r2e-scheduler
r2e add cache         # r2e-cache
r2e add rate-limit    # r2e-rate-limit
r2e add utils         # r2e-utils
r2e add test          # r2e-test (dev-dependency)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<p>Full API documentation is available via <code>cargo doc</code>.</p>
<h2 id="generating-docs"><a class="header" href="#generating-docs">Generating docs</a></h2>
<pre><code class="language-bash">cargo doc --workspace --no-deps --open
</code></pre>
<p>This generates and opens documentation for all R2E crates.</p>
<h2 id="key-types-by-crate"><a class="header" href="#key-types-by-crate">Key types by crate</a></h2>
<h3 id="r2e-core"><a class="header" href="#r2e-core">r2e-core</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>AppBuilder</code></td><td>Fluent application builder</td></tr>
<tr><td><code>AppError</code></td><td>Built-in error type with HTTP status mapping</td></tr>
<tr><td><code>R2eConfig</code></td><td>YAML + env var configuration</td></tr>
<tr><td><code>Controller</code></td><td>Trait for route registration</td></tr>
<tr><td><code>Guard&lt;S, I&gt;</code></td><td>Post-auth guard trait</td></tr>
<tr><td><code>PreAuthGuard&lt;S&gt;</code></td><td>Pre-auth guard trait</td></tr>
<tr><td><code>GuardContext&lt;I&gt;</code></td><td>Guard context with identity</td></tr>
<tr><td><code>PreAuthGuardContext</code></td><td>Guard context without identity</td></tr>
<tr><td><code>Identity</code></td><td>Identity trait for guards</td></tr>
<tr><td><code>Interceptor&lt;R&gt;</code></td><td>AOP interceptor trait</td></tr>
<tr><td><code>InterceptorContext</code></td><td>Interceptor context</td></tr>
<tr><td><code>ManagedResource&lt;S&gt;</code></td><td>Managed resource lifecycle trait</td></tr>
<tr><td><code>ManagedErr&lt;E&gt;</code></td><td>Error wrapper for managed resources</td></tr>
<tr><td><code>Plugin&lt;S&gt;</code></td><td>Post-state plugin trait</td></tr>
<tr><td><code>PreStatePlugin</code></td><td>Pre-state plugin trait</td></tr>
<tr><td><code>DeferredAction</code></td><td>Deferred setup action for plugins</td></tr>
<tr><td><code>StatefulConstruct&lt;S&gt;</code></td><td>Construct from state (no HTTP context)</td></tr>
<tr><td><code>Bean</code></td><td>Sync bean trait</td></tr>
<tr><td><code>AsyncBean</code></td><td>Async bean trait</td></tr>
<tr><td><code>Producer</code></td><td>Factory trait for external types</td></tr>
<tr><td><code>BeanContext</code></td><td>Bean graph context</td></tr>
<tr><td><code>Validated&lt;T&gt;</code></td><td>Validation extractor (feature: <code>validation</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-macros"><a class="header" href="#r2e-macros">r2e-macros</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Macro</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>#[derive(Controller)]</code></td><td>Generate controller metadata and extractor</td></tr>
<tr><td><code>#[routes]</code></td><td>Generate Axum handlers and Controller impl</td></tr>
<tr><td><code>#[bean]</code></td><td>Generate Bean or AsyncBean impl</td></tr>
<tr><td><code>#[producer]</code></td><td>Generate Producer impl from free function</td></tr>
<tr><td><code>#[derive(Bean)]</code></td><td>Derive Bean from struct fields</td></tr>
<tr><td><code>#[derive(BeanState)]</code></td><td>Derive FromRef for state struct</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-security"><a class="header" href="#r2e-security">r2e-security</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>AuthenticatedUser</code></td><td>JWT identity extractor</td></tr>
<tr><td><code>JwtClaimsValidator</code></td><td>Low-level JWT validator</td></tr>
<tr><td><code>JwtValidator</code></td><td>High-level JWT validator with identity builder</td></tr>
<tr><td><code>SecurityConfig</code></td><td>JWT/JWKS configuration</td></tr>
<tr><td><code>JwksCache</code></td><td>JWKS key cache</td></tr>
<tr><td><code>RoleExtractor</code></td><td>Trait for custom role extraction</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-events"><a class="header" href="#r2e-events">r2e-events</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>EventBus</code></td><td>Typed in-process pub/sub</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-scheduler"><a class="header" href="#r2e-scheduler">r2e-scheduler</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Scheduler</code></td><td>PreStatePlugin for background tasks</td></tr>
<tr><td><code>ScheduleConfig</code></td><td>Interval/cron/delay configuration</td></tr>
<tr><td><code>ScheduledTaskDef&lt;T&gt;</code></td><td>Task definition</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-data"><a class="header" href="#r2e-data">r2e-data</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Entity</code></td><td>Table mapping trait</td></tr>
<tr><td><code>QueryBuilder</code></td><td>Fluent SQL builder</td></tr>
<tr><td><code>Pageable</code></td><td>Pagination parameters</td></tr>
<tr><td><code>Page&lt;T&gt;</code></td><td>Paginated response</td></tr>
<tr><td><code>DataError</code></td><td>Data layer error</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-data-sqlx"><a class="header" href="#r2e-data-sqlx">r2e-data-sqlx</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>SqlxRepository&lt;E, DB&gt;</code></td><td>SQLx-backed repository</td></tr>
<tr><td><code>Tx&lt;DB&gt;</code></td><td>Transaction wrapper</td></tr>
<tr><td><code>HasPool&lt;DB&gt;</code></td><td>Pool accessor trait</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-cache"><a class="header" href="#r2e-cache">r2e-cache</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>TtlCache&lt;K, V&gt;</code></td><td>Thread-safe TTL cache</td></tr>
<tr><td><code>CacheStore</code></td><td>Pluggable cache backend trait</td></tr>
<tr><td><code>InMemoryStore</code></td><td>Default in-memory backend</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-rate-limit"><a class="header" href="#r2e-rate-limit">r2e-rate-limit</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>RateLimiter&lt;K&gt;</code></td><td>Token-bucket rate limiter</td></tr>
<tr><td><code>RateLimitRegistry</code></td><td>Rate limiter handle for app state</td></tr>
<tr><td><code>RateLimit</code></td><td>Builder for rate limit guards</td></tr>
<tr><td><code>RateLimitBackend</code></td><td>Pluggable backend trait</td></tr>
</tbody>
</table>
</div>
<h3 id="r2e-test"><a class="header" href="#r2e-test">r2e-test</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>TestApp</code></td><td>In-process HTTP client</td></tr>
<tr><td><code>TestResponse</code></td><td>Response with assertion helpers</td></tr>
<tr><td><code>TestJwt</code></td><td>JWT token generator</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
