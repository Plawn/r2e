use jsonwebtoken::{encode, Algorithm, DecodingKey, EncodingKey, Header};
use r2e_security::{JwtClaimsValidator, JwtValidator, SecurityConfig};
use serde_json::Value;

/// Test helper for generating JWT tokens and a matching `JwtValidator`.
///
/// Uses HS256 with a static secret for deterministic, fast test setup.
pub struct TestJwt {
    secret: Vec<u8>,
    issuer: String,
    audience: String,
}

impl TestJwt {
    /// Create a new `TestJwt` with default test settings.
    pub fn new() -> Self {
        Self {
            secret: b"r2e-test-secret-do-not-use-in-production".to_vec(),
            issuer: "r2e-test".to_string(),
            audience: "r2e-test-app".to_string(),
        }
    }

    /// Create a new `TestJwt` with custom issuer and audience.
    pub fn with_config(secret: &[u8], issuer: &str, audience: &str) -> Self {
        Self {
            secret: secret.to_vec(),
            issuer: issuer.to_string(),
            audience: audience.to_string(),
        }
    }

    /// Generate a signed JWT token for the given subject and roles.
    pub fn token(&self, sub: &str, roles: &[&str]) -> String {
        self.token_with_claims(sub, roles, None)
    }

    /// Generate a signed JWT token with optional email.
    pub fn token_with_claims(&self, sub: &str, roles: &[&str], email: Option<&str>) -> String {
        self.token_builder(sub)
            .roles(roles)
            .email_opt(email)
            .build()
    }

    /// Create a `TokenBuilder` for constructing tokens with custom claims.
    pub fn token_builder(&self, sub: &str) -> TokenBuilder<'_> {
        TokenBuilder {
            jwt: self,
            sub: sub.to_string(),
            roles: Vec::new(),
            email: None,
            extra_claims: serde_json::Map::new(),
            exp_secs: 3600,
        }
    }

    /// Build a `JwtValidator` that accepts tokens generated by this `TestJwt`.
    pub fn validator(&self) -> JwtValidator {
        let config = SecurityConfig::new("unused", &self.issuer, &self.audience);
        JwtValidator::new_with_static_key(
            DecodingKey::from_secret(&self.secret),
            config,
        )
    }

    /// Build a `JwtClaimsValidator` that accepts tokens generated by this `TestJwt`.
    ///
    /// Use this when testing controllers that use `AuthenticatedUser` as their identity type.
    pub fn claims_validator(&self) -> JwtClaimsValidator {
        let config = SecurityConfig::new("unused", &self.issuer, &self.audience);
        JwtClaimsValidator::new_with_static_key(
            DecodingKey::from_secret(&self.secret),
            config,
        )
    }
}

impl Default for TestJwt {
    fn default() -> Self {
        Self::new()
    }
}

/// Builder for constructing JWT tokens with custom claims and expiration.
pub struct TokenBuilder<'a> {
    jwt: &'a TestJwt,
    sub: String,
    roles: Vec<String>,
    email: Option<String>,
    extra_claims: serde_json::Map<String, Value>,
    exp_secs: u64,
}

impl<'a> TokenBuilder<'a> {
    /// Set the roles for this token.
    pub fn roles(mut self, roles: &[&str]) -> Self {
        self.roles = roles.iter().map(|r| r.to_string()).collect();
        self
    }

    /// Set the email claim.
    pub fn email(mut self, email: &str) -> Self {
        self.email = Some(email.to_string());
        self
    }

    /// Set the email claim from an `Option`. Does nothing if `None`.
    fn email_opt(mut self, email: Option<&str>) -> Self {
        if let Some(e) = email {
            self.email = Some(e.to_string());
        }
        self
    }

    /// Add a custom claim to the token.
    pub fn claim(mut self, key: &str, value: impl Into<Value>) -> Self {
        self.extra_claims.insert(key.to_string(), value.into());
        self
    }

    /// Set the token expiration in seconds from now.
    pub fn expires_in_secs(mut self, secs: u64) -> Self {
        self.exp_secs = secs;
        self
    }

    /// Make the token already expired (exp = 0).
    pub fn expired(mut self) -> Self {
        self.exp_secs = 0;
        self
    }

    /// Build and sign the JWT token.
    pub fn build(self) -> String {
        let exp = if self.exp_secs == 0 {
            0u64
        } else {
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs()
                + self.exp_secs
        };

        let mut claims = serde_json::json!({
            "sub": self.sub,
            "roles": self.roles,
            "iss": self.jwt.issuer,
            "aud": self.jwt.audience,
            "exp": exp,
        });

        if let Some(email) = &self.email {
            claims["email"] = Value::String(email.clone());
        }

        // Merge extra claims
        if let Value::Object(map) = &mut claims {
            for (k, v) in self.extra_claims {
                map.insert(k, v);
            }
        }

        let header = Header::new(Algorithm::HS256);
        encode(&header, &claims, &EncodingKey::from_secret(&self.jwt.secret))
            .expect("failed to encode test JWT")
    }
}
