use std::fmt;

/// Trait for gRPC services that can be registered with the R2E builder.
///
/// Implement this trait (typically via the `#[grpc_routes]` macro) to wire
/// a tonic service into the R2E application.
///
/// # Example (generated by macro)
///
/// ```ignore
/// impl GrpcService<Services> for UserGrpcService {
///     fn service_name() -> &'static str {
///         "mypackage.UserService"
///     }
///
///     fn into_router(state: &Services) -> tonic::transport::server::Router {
///         let wrapper = __R2eGrpc_UserGrpcService { state: state.clone() };
///         tonic::transport::Server::builder()
///             .add_service(proto::user_service_server::UserServiceServer::new(wrapper))
///     }
/// }
/// ```
pub trait GrpcService<T: Clone + Send + Sync + 'static>: 'static {
    /// The proto service name (e.g., "mypackage.UserService").
    fn service_name() -> &'static str;

    /// Create a tonic Router containing this service, built from the app state.
    fn into_router(state: &T) -> tonic::transport::server::Router;
}

/// A collected gRPC service factory, type-erased for storage in the registry.
pub(crate) struct GrpcServiceFactory<T: Clone + Send + Sync + 'static> {
    pub name: &'static str,
    pub factory: Box<dyn FnOnce(&T) -> tonic::transport::server::Router + Send>,
}

impl<T: Clone + Send + Sync + 'static> fmt::Debug for GrpcServiceFactory<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("GrpcServiceFactory")
            .field("name", &self.name)
            .finish()
    }
}
