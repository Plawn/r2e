use jsonwebtoken::{encode, Algorithm, DecodingKey, EncodingKey, Header};
use quarlus_security::{JwtValidator, SecurityConfig};

/// Test helper for generating JWT tokens and a matching `JwtValidator`.
///
/// Uses HS256 with a static secret for deterministic, fast test setup.
pub struct TestJwt {
    secret: Vec<u8>,
    issuer: String,
    audience: String,
}

impl TestJwt {
    /// Create a new `TestJwt` with default test settings.
    pub fn new() -> Self {
        Self {
            secret: b"quarlus-test-secret-do-not-use-in-production".to_vec(),
            issuer: "quarlus-test".to_string(),
            audience: "quarlus-test-app".to_string(),
        }
    }

    /// Create a new `TestJwt` with custom issuer and audience.
    pub fn with_config(secret: &[u8], issuer: &str, audience: &str) -> Self {
        Self {
            secret: secret.to_vec(),
            issuer: issuer.to_string(),
            audience: audience.to_string(),
        }
    }

    /// Generate a signed JWT token for the given subject and roles.
    pub fn token(&self, sub: &str, roles: &[&str]) -> String {
        self.token_with_claims(sub, roles, None)
    }

    /// Generate a signed JWT token with optional email.
    pub fn token_with_claims(&self, sub: &str, roles: &[&str], email: Option<&str>) -> String {
        let exp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
            + 3600;

        let mut claims = serde_json::json!({
            "sub": sub,
            "roles": roles,
            "iss": self.issuer,
            "aud": self.audience,
            "exp": exp,
        });

        if let Some(email) = email {
            claims["email"] = serde_json::Value::String(email.to_string());
        }

        let header = Header::new(Algorithm::HS256);
        encode(&header, &claims, &EncodingKey::from_secret(&self.secret))
            .expect("failed to encode test JWT")
    }

    /// Build a `JwtValidator` that accepts tokens generated by this `TestJwt`.
    pub fn validator(&self) -> JwtValidator {
        let config = SecurityConfig::new("unused", &self.issuer, &self.audience);
        JwtValidator::new_with_static_key(
            DecodingKey::from_secret(&self.secret),
            config,
        )
    }
}

impl Default for TestJwt {
    fn default() -> Self {
        Self::new()
    }
}
