//! Compile-time type-level list for tracking provided bean types.
//!
//! This module implements a type-level linked list that enables the compiler to
//! verify at compile time that all required types have been provided to the
//! [`AppBuilder`](crate::AppBuilder) before calling `build_state()`.
//!
//! # How It Works
//!
//! The type-level list is built using two types:
//! - [`TNil`]: Represents an empty list
//! - [`TCons<H, T>`]: A "cons cell" where `H` is the head type and `T` is the tail
//!
//! When you call `.provide::<T>()` or `.with_bean::<T>()` on the builder, the
//! provision type parameter grows:
//!
//! ```text
//! AppBuilder<NoState, TNil>                    // Initial: empty list
//!     .provide(pool)                           // → AppBuilder<NoState, TCons<Pool, TNil>>
//!     .with_bean::<UserService>()              // → AppBuilder<NoState, TCons<UserService, TCons<Pool, TNil>>>
//! ```
//!
//! # Compile-Time Verification
//!
//! When `build_state::<Services>()` is called, the compiler checks that `Services`
//! implements `BuildableFrom<P, Indices>` where `P` is the current provision list.
//! This trait is auto-generated by `#[derive(BeanState)]` with bounds like:
//!
//! ```text
//! impl<P, I0, I1> BuildableFrom<P, (I0, I1)> for Services
//! where
//!     P: Contains<Pool, I0>,
//!     P: Contains<UserService, I1>,
//! {}
//! ```
//!
//! If a required type is missing, the compiler produces a clear error message
//! thanks to `#[diagnostic::on_unimplemented]`.
//!
//! # Example
//!
//! ```ignore
//! // This compiles:
//! AppBuilder::new()
//!     .provide(pool)
//!     .with_bean::<UserService>()
//!     .build_state::<Services>()  // ✓ Pool and UserService are both provided
//!     .await
//!
//! // This fails at compile time with a helpful error:
//! AppBuilder::new()
//!     .provide(pool)
//!     .build_state::<Services>()  // ✗ UserService not provided
//!     .await
//! // Error: type `UserService` was not provided to the AppBuilder
//! //        missing `.provide::<UserService>()` or `.with_bean::<UserService>()`
//! ```
//!
//! # Index Witnesses
//!
//! The `Idx` parameter in [`Contains<H, Idx>`] is an "index witness" that tells
//! the compiler where in the list the type was found:
//! - [`Here`]: The type is at the head of the list
//! - [`There<I>`]: The type is somewhere in the tail (recursively)
//!
//! This mechanism avoids overlapping trait implementations and allows the compiler
//! to resolve each `Contains` bound independently.

use std::marker::PhantomData;

/// Empty type-level list.
///
/// Represents a provision list with no types. This is the initial state of
/// `AppBuilder::new()`.
pub struct TNil;

/// Cons cell: `H` is a provided type, `T` is the rest of the list.
///
/// Each call to `.provide::<T>()` or `.with_bean::<T>()` wraps the current
/// list in a new `TCons`:
///
/// ```text
/// TCons<UserService, TCons<Pool, TNil>>
///   │                  │
///   │                  └─ Pool was provided first
///   └─ UserService was provided second
/// ```
///
/// Uses `PhantomData<fn() -> (H, T)>` to avoid imposing `Send`/`Sync`
/// constraints on phantom type parameters.
pub struct TCons<H, T>(PhantomData<fn() -> (H, T)>);

/// Index witness: the element was found at the head of the list.
///
/// Used in `Contains<H, Here>` to indicate that type `H` is the first
/// element of the type-level list.
pub struct Here;

/// Index witness: the element was found somewhere in the tail.
///
/// Used in `Contains<H, There<I>>` to indicate that type `H` is not at
/// the head, but somewhere deeper in the list at index `I`.
pub struct There<T>(PhantomData<fn() -> T>);

/// Compile-time witness that type `H` is present in the type-level list `Self`,
/// located at position `Idx`.
///
/// The `Idx` parameter is an index witness (`Here` or `There<...>`) that guides
/// the compiler's trait resolution and avoids overlapping impls. It is always
/// inferred automatically — users never need to specify it.
///
/// # Trait Implementations
///
/// ```text
/// // Base case: H is at the head
/// impl<H, T> Contains<H, Here> for TCons<H, T> {}
///
/// // Recursive case: H is in the tail
/// impl<H, X, T, I> Contains<H, There<I>> for TCons<X, T>
/// where T: Contains<H, I> {}
/// ```
#[diagnostic::on_unimplemented(
    message = "type `{H}` was not provided to the AppBuilder",
    label = "missing `.provide::<{H}>()` or `.with_bean::<{H}>()`",
    note = "every field type in the BeanState struct must be provided or registered as a bean before calling `build_state()`"
)]
pub trait Contains<H, Idx> {}

// Base case: H is the head of the list.
impl<H, T> Contains<H, Here> for TCons<H, T> {}

// Recursive case: H is somewhere in the tail.
impl<H, X, T, I> Contains<H, There<I>> for TCons<X, T> where T: Contains<H, I> {}

/// Marker trait: all types required by the state struct are present in the
/// type-level provision list `P`.
///
/// Generated automatically by `#[derive(BeanState)]`. The `Indices` parameter
/// bundles one index witness per unique field type so the compiler can
/// independently resolve each [`Contains`] bound. Users never specify
/// `Indices` — it is always inferred by the compiler.
///
/// # Generated Implementation Example
///
/// For a state struct like:
///
/// ```ignore
/// #[derive(BeanState)]
/// struct Services {
///     user_service: UserService,
///     pool: Pool,
/// }
/// ```
///
/// The derive macro generates:
///
/// ```ignore
/// impl<__P, __I0, __I1> BuildableFrom<__P, (__I0, __I1)> for Services
/// where
///     __P: Contains<UserService, __I0>,
///     __P: Contains<Pool, __I1>,
/// {}
/// ```
///
/// This allows `AppBuilder::build_state::<Services>()` to verify at compile
/// time that both `UserService` and `Pool` have been provided.
#[diagnostic::on_unimplemented(
    message = "cannot build state `{Self}` from the current provisions",
    note = "one or more field types are missing — add `.provide(value)` or `.with_bean::<Type>()` calls before `.build_state()`"
)]
pub trait BuildableFrom<P, Indices> {}
